#  机试总结

无他，唯手熟尔。

By Pt

# ----------【机试基础】----------

## 万能头文件

```c++
#include<bits/stdc++.h>这个头文件包含以下等等C++中包含的所有头文件：
#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cmath>
#include <deque>
#include <vector>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <stack>
#include <set>
等等……
```

不过在国内oj中，==poj，hdu 不支持这个函数==，这几个oj的编译器问题，其他国外的oj，还有台湾的oj都支持，CF，Topcoder也都支持。



- **malloc #include<stdlib.h>**

## 使用文件进行输入输出重定向
```c
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
```



## CASE语句

```c
#include<stdio.h>

int main()
{
	int year, month, days;
	printf("input year and month\n");
	scanf("%d, %d", &year, &month);
	switch(month)
	{
		case 1:
		case 3:
		case 5:					
		case 7:
		case 8:
		case 10:
		case 12: days = 31; break;
		case 4:
		case 6:
		case 9:
		case 11: days = 30; break; 
		case 2: if( (year % 4 == 0) && (year % 100 != 0) || year % 400 == 0) days = 29;
				else days = 28;
				break;
		default: printf("Error input");
	}
	printf("year = %d month = %d days = %d", year, month, days);
	return 0;
} 
```

或者可以直接给days赋值30，然后其他情况改变days的值。

## 数组的初始化

```c
int a[3] = {1, 2, 3};
int a[] = {1, 2, 3};
int a[5];

int b[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int b[][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int b[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

char s[8] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}; 
char s[] = "boy";
```

## 字符串的输入和输出



**scanf("%c") 接受空格**

**scnaf("%s") 不接受空格**





### 逐个字符输入输出

```c
#include<stdio.h>

int main()
{
	int i;
	char str[10];
	for(i = 0; i < 9; i ++)
	{
		//scanf("%c", &str[i]);
		str[i] = getchar();
	}
	str[i] = '\0';
	for(i = 0; i < 9; i ++)
		//printf("%c",str[i]);
		putchar(str[i]);
	return 0;
}
```

### 字符串整体输入输出

```c
scanf -> %s 直接加数组名即可，因为数组名也代表了数组第一个元素的首地址
gets(str);
puts(str);(结尾自动加回车)
```

### 字符串处理函数

1. 复制 strcpy

   strcpy(str1, str2); 把后者复制到前者

   strcpy(str, str2, 3); 把后者的前3个字符复制到前者

   (C不允许直接str1 = str2)

2. 连接 strcat

   strcat(str1, str2); 把后者连接到前者，但是前者必须足够大

3. 比较 strcmp

   strcmp(str1, str2) = 0

   相等 返回0

   大于 返回正整数

   小于 返回负整数

   ```c++
   #include<string.h>
   #include<stdio.h>

   int main()
   {
       char a[] = "abc";
       char b[] = "abcd";
       printf("%d", strcmp(a, b)); //-1
       return 0;
   }

   ```

   ​

4. 长度 strlen(str)

5. 大写转小写 strlwr(str)

6. 小写转大写 strupr(str)

7. 查找元素'x'第一次出现的位置的指针 strchr(str, 'x')

   ​


## 结构体

```c
#include<stdio.h>

#define NAMESIZE 20
//间接定义 
struct student
{
	long number;
	char name[NAMESIZE];
	int age;
	int score;
};
struct student p;

//直接定义 
struct student
{
	long number;
	char name[NAMESIZE];
	int age;
	int score;
} p;

//无名定义
struct
{
	long number;
	char name[NAMESIZE];
	int age;
	int score;
} p;

p.age
```

## 结构体数组

```c
struct student
{
	long number;
	char name[NAMESIZE];
	int age;
	int score;
};

sturct student std[3];
```



## Runtime Error

runtime  error （运行时错误）就是程序运行到一半，程序就崩溃了。

比如说：

①除以零

②数组越界：int a[3]; a[10000000]=10;

③指针越界：int * p; p=(int *)malloc(5 * sizeof(int)); *(p+1000000)=10;

④使用已经释放的空间：int * p; p=(int *)malloc(5 * sizeof(int));free(p); *p=10;

⑤数组开得太大，超出了栈的范围，造成栈溢出：int a[100000000];



# ----------【数据结构】----------

## 链表

###题目1181：遍历链表
时间限制：1 秒内存限制：32 兆特殊判题：否提交：3907解决：1658
题目描述：
建立一个升序链表并遍历输出。
输入：
输入的每个案例中第一行包括1个整数：n(1<=n<=1000)，接下来的一行包括n个整数。
输出：
可能有多组测试数据，对于每组数据，
将n个整数建立升序链表，之后遍历链表并输出。
样例输入：
4
3 5 7 9
样例输出：
3 5 7 9
来源：
2000年华中科技大学计算机研究生机试真题

```c++
#include<stdio.h>
#define MAX 1010

int a[MAX];
int next[MAX], p;

int main()
{
    int n;
    while(scanf("%d", &n) != EOF)
    {
        next[0] = 0;
        for(int i = 1; i <= n; i ++)
        {
            scanf("%d", &a[i]);
            p = 0; //ERROR:position
            while(next[p] != 0 && a[next[p]] < a[i]) p = next[p];
            next[i] = next[p];
            next[p] = i;
        }
        for(int i = next[0]; i != 0; i = next[i])
        {
            if(i != next[0]) printf(" ");
            printf("%d", a[i]);
        }
        printf("\n");
    }
    return 0;
}


```



```c++
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
using namespace std;

struct Node
{
    int num;
    Node* next;
};

int a[1010], n;
Node* point;
Node* head;


void getLink()
{
    point = head;
    for(int i = 0; i < n; i ++)
    {
        Node* p = (Node*)malloc(sizeof(Node));
        p -> num = a[i];
        p -> next = NULL;
        point -> next = p;
        point = p;
    }
}

void print()
{
    Node* p = head;
    int first = 1;
    while(p -> next != NULL)
    {
        p = p -> next;
        if(!first) printf(" ");
        else
            first = 0;
        printf("%d", p -> num);
    }
    printf("\n");
}

void clean(Node* p) //Error
{
    Node* pre;
    while(p != NULL)
    {
        pre = p;
        p = p -> next;
        free(pre);
    }
}

int main()
{
    //freopen("in1181.txt", "r", stdin);
    while(scanf("%d", &n) != EOF)
    {
        head = (Node*)malloc(sizeof(Node)); //Error: never forget create the head point and init it!
        for(int i = 0; i < n ; i ++)
        {
            scanf("%d", &a[i]);
        }
        sort(a, a + n);
        getLink();
        print();
        clean(head);
    }
    return 0;
}
```

指针链表非常容易错

### UVa11988 Broken Keyboard(悲剧文本) 【数组链表的实现】

题目描述：

输入包含多组数据，每组数据占一行，包含不超过100000个字母、下划线、字符“[”或者“]”。其中字符“[”表示Home键，“]”表示End键。输入结束标志为文件结束符（EOF）输入文件不超过5MB，对于每组数据，输出一行，即屏幕上的悲剧文本

样例输入：
```
This_is_a_[Beiju]_text
[[]][]Happy_Birthday_to_Tsinghua_University
```
样例输出：
```
BeijuThis_is_a__text
Happy_Birthday_to_Tsinghua_University
```

- 思路
  【用什么数据结构】
  用数组来保存文本，设置pos保存当前光标位置，然后根据输入来插入字符。这样可能会超时，因为一个字符的插入要引起大量字符的右移。因此解决方案应该用链表。
  【如何用数组实现链表】
  设置数组next[i]表示标号为i的字符（str[i]）的下一个字符标号(相当于i - > next)。str[0]是虚拟的首节点。则next[0]表示链表中的最左边的字符标号。

cur表示光标位置，在cur后面进行插入，last表示最后一个元素的标号。最初我们需要一个头结点，不妨将它设为0，即Next[0]=0。头结点只是起到一个标记的作用，不表示真实的位置。链表中的头结点总是指向链表的第一个元素。然后开始插入元素。链表中插入元素就两句代码：Next[i]=head;head=i。第一句表示新元素i的下一个元素指向当前head指向的元素，第二句话是更新head的指向，指向新的第一个元素i。当所有元素插入完毕后，只需要从头结点开始，顺着Next数组即可按顺序输出整个链表。注意，这样的插入实际上是在尾部插入，链表的尾部在不断地变长。这道题中用cur来当做头结点，通过移动头结点的位置即可实现在链表的不同位置插入新元素。根据题意，当遇到‘['时，头结点变为0，遇到‘]'时，头结点变为last即可。详细过程见代码注释。

```c++
#include<stdio.h>
#include<string.h>
#define MAX 100010

char str[MAX];
int next[MAX], cur, last; //当前和结尾的标号

int main()
{
    //freopen("in.txt", "r", stdin);
    while(scanf("%s", str + 1) != EOF)
    {
        int len = strlen(str + 1); //Error:str + 1
        last = cur = 0;
        next[0] = 0;

        for(int i = 1; i <= len; i ++) //Error: <=
        {
            if(str[i] == '[') cur = 0;
            else if(str[i] == ']') cur = last;
            else
            {
                next[i] = next[cur];
                next[cur] = i;
                if(cur == last) last = i;
                cur = i;
            }
        }
        for(int i = next[0]; i != 0; i = next[i])
            printf("%c", str[i]);
        printf("\n");
    }
    return 0;
}
```



## 树

### 1184 前序建树中序遍历输出

题目1184：二叉树遍历
时间限制：1 秒内存限制：32 兆特殊判题：否提交：4711解决：1910
题目描述：
编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。
例如如下的先序遍历字符串：
ABC##DE#G##F###
其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。
输入：
输入包括1行字符串，长度不超过100。
输出：
可能有多组测试数据，对于每组数据，
输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。
每个输出结果占一行。
样例输入：
abc##de#g##f###
样例输出：
c b e g d f a 
来源：
2002年华中科技大学计算机研究生机试真题

- 注意

每次获取新的输入数据都要将全局变量初始化，并且free掉之前建立的树

- 代码

  ```c
  #include<stdio.h>
  #include<stdlib.h> //malloc

  char str[110];

  struct Node
  {
      char data;
      Node* lChild;
      Node* rChild;
  };

  Node* root;

  int i = 0;

  Node* getTree()
  {
      Node* p;
      char t = str[i ++];
      if(t == '#') p = NULL;
      else
      {
          p = (Node*)malloc(sizeof(Node));
          p -> data = t;
          p -> lChild = getTree();
          p -> rChild = getTree();
      }
      return p;
  }

  void inOrder(Node* p)
  {
      if(p != NULL)
      {
          inOrder(p -> lChild);
          printf("%c ", p -> data);
          inOrder(p -> rChild);
      }
  }

  void clean(Node* p) //important!
  {
      if(p != NULL)
      {
          clean(p -> lChild);
          clean(p -> rChild);
          free(p);
      }
  }

  int main()
  {
      while(gets(str))
      {
          i = 0;
          root = getTree();
          inOrder(root);
          clean(root);
          printf("\n");
      }
      return 0;
  }
  ```

  ​


###UVa122  二叉树的层次遍历 

（经典好题输入是个大问题）http://www.jianshu.com/p/7dadc177254a

### UVa 给定二叉树的中序后续求最小权值路径的叶子

```c++
#include<iostream>
#include<stdio.h>
#include<string>
#include<string.h>
#include<sstream>
#define MAX 10010

using namespace std;

int inOrder[MAX], postOrder[MAX], len;

//Tree
int lChild[MAX], rChild[MAX];

bool input(int* a) //very very important
{
    stringstream stream;
    string s;
    if( !getline(cin, s) ) return false;
    stream << s;
    int x;
    len = 0;
    while(stream >> x) a[len ++] = x;
    return true;
}

int getTree(int start1, int end1, int start2, int end2) // inorder[start1...end1] and postorder[start2...end2] get the tree and return the root
{
    if(start1 > end1) return 0; // empty tree
    int root = postOrder[end2];
    int p = start1;
    while(inOrder[p] != root) p ++;
    int leftTreeNum = p - start1;
    lChild[root] = getTree(start1, p - 1, start2, start2 + leftTreeNum - 1);
    rChild[root] = getTree(p + 1, end1, start2 + leftTreeNum, end2 - 1); //Error : end1 -> end2 !

    return root;
}


int bestLeaf, bestSum;

void dfs(int node, int sum)
{
    sum += node;
    if(lChild[node] == 0 && rChild[node] == 0)
    {
        if(sum < bestSum || sum == bestSum && node < bestLeaf)
        {
            bestLeaf = node;
            bestSum = sum;
        }
    }
    if(lChild[node]) dfs(lChild[node], sum);
    if(rChild[node]) dfs(rChild[node], sum);
}

int main()
{
    freopen("in.txt", "r", stdin);
    while(input(inOrder))
    {
        input(postOrder);
        getTree(0, len - 1, 0, len - 1); //get the tree from in order and post order
        //for(int i = 0; i < 9; i ++) printf("%d l : %d r : %d\n", i, lChild[i], rChild[i]);
        bestSum = 100000000;
        dfs(postOrder[len - 1], 0);
        cout << bestLeaf << endl;
    }
    return 0;
}
```



### 题目1201：二叉排序树
时间限制：1 秒内存限制：32 兆特殊判题：否提交：8560解决：3676
题目描述：
    输入一系列整数，建立二叉排序数，并进行前序，中序，后序遍历。
输入：
    输入第一行包括一个整数n(1<=n<=100)。
    接下来的一行包括n个整数。
输出：
    可能有多组测试数据，对于每组数据，将题目所给数据建立一个二叉排序树，并对二叉排序树进行前序、中序和后序遍历。
    每种遍历结果输出一行。每行最后一个数据之后有一个空格。
样例输入：
5
1 6 5 9 8
样例输出：
1 6 5 9 8 
1 5 6 8 9 
5 8 9 6 1 
提示：
输入中可能有重复元素，但是输出的二叉树遍历序列中重复元素不用输出。
来源：
2005年华中科技大学计算机保研机试真题

- 思路
  建立二叉搜索树的算法：插入x
  1.若当前树为空，则x是其根节点
  2.若当前节点>x，则插入左子树；<x，则插入右子树。若等于x，则根据实际情况插入左右子树，或者直接忽略。

- 代码注意
1. 开辟静态数组存储节点，设置全局变量保存节点个数。
2. 注意创建新节点的函数。
3. 注意插入节点的函数，是递归写出来的。
  插入节点的函数可以这样写
```c++

void getTree(Node* &T, int x)
{
    if(T == NULL)
    {
        T = create();
        T -> data = x;
        //return T;
    }
    else if(x < T -> data)
        getTree(T -> l, x);
    else if(x >T -> data)
        getTree(T -> r, x);
    //return T;
}
```


- 代码
```c++
#include<stdio.h>

struct Node
{
    int data;
    Node* l;
    Node* r;
}Tree[110];

int loc;

Node* create()
{
    Tree[loc].l = Tree[loc].r = NULL;
    return &Tree[loc ++];
}

void preOrder(Node* T)
{
    if(T != NULL)
    {
        printf("%d ", T -> data);
        preOrder(T -> l);
        preOrder(T -> r);
    }
}

void midOrder(Node* T)
{
    if(T != NULL)
    {
        midOrder(T -> l);
        printf("%d ", T -> data);
        midOrder(T -> r);
    }
}

void postOrder(Node* T)
{
    if(T != NULL)
    {
        postOrder(T -> l);
        postOrder(T -> r);
        printf("%d ", T -> data);
    }
}

Node* getTree(Node* T, int x)
{
    if(T == NULL)
    {
        T = create();
        T -> data = x;
        return T;
    }
    else if(x < T -> data)
        T -> l = getTree(T -> l, x);
    else if(x >T -> data)
        T -> r = getTree(T -> r, x);
    return T;
}

int main()
{
    int n;
    while(scanf("%d", &n) != EOF)
    {
        //初始化
        loc = 0;
        Node* root = NULL;
        for(int i = 0; i < n; i ++)
        {
            int x;
            scanf("%d", &x);
            root = getTree(root, x);
        }
        preOrder(root);
        printf("\n");
        midOrder(root);
        printf("\n");
        postOrder(root);
        printf("\n");
    }
    return 0;
}

```



## 图

### 实现方式

1.邻接矩阵
2.邻接链表
```c++

vector<int> G[MAX];
/*
struct edge
{
    int to;
    int cost;
};
vector<edge> G[MAX];
*/
int main()
{
    int v, e;
    scanf("%d%d", &v, &e);
    for(int i = 0; i < e; i ++)
    {
        int s, t;
        scanf("%d%d", &s, &t);
        G[s].push_back(t);
    }

    return 0;
}
```

## 并查集  

## 堆栈

## 队列

##  

# ----------【基本算法】----------

## Dijkstra求单源点到所有点最短路径问题

###题目1008：最短路径问题
时间限制：1 秒内存限制：32 兆特殊判题：否提交：12525解决：4300
题目描述：
给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。
输入：
输入n,m，点的编号是1~n,然后是m行，每行4个数 a,b,d,p，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 s,t;起点s，终点t。n和m为0时输入结束。
(1<n<=1000, 0<m<100000, s != t)
输出：
输出 一行有两个数， 最短距离及其花费。
样例输入：
3 2
1 2 5 6
2 3 4 5
1 3
0 0
样例输出：
9 11

```c++
#include<stdio.h>
#define MAX 1010
#define INF 0x3f3f3f3f
int n, m, s, t;

int d[MAX][MAX];
int p[MAX][MAX];

int dd[MAX];
int pp[MAX];
int pre[MAX];

int visited[MAX];

void init()
{
    for(int i = 1; i <= n; i ++)
    {
        dd[i] = pp[i] = INF;
        visited[i] = 0;
        pre[i] = -1;
        for(int j = 1; j <= n; j ++)
        {
            d[i][j] = INF;
            p[i][j] = INF;
        }
    }
}

void dijkstra()
{
    dd[s] = pp[s] = 0;
    for(int j = 1; j <= n; j ++)
    {
        int k = -1;
        int Min = INF;
        for(int i = 1; i <= n; i ++)
        {
            if(!visited[i] && dd[i] < Min)
            {
                Min = dd[i];
                k = i;
            }
        }
        if(k == -1 || k == t) break;
        visited[k] = 1;
        for(int i = 1; i <= n; i ++)
        {
            if(!visited[i] && dd[k] + d[k][i] < dd[i])
            {
                dd[i] = dd[k] + d[k][i];
                pre[i] = k;
                pp[i] = pp[k] + p[k][i];
            }
        }
    }
}

void input()
{
    for(int i = 0; i < m; i ++)
    {
        int a, b, dis, pri;
        scanf("%d%d%d%d", &a, &b, &dis, &pri);
        d[a][b] = d[b][a] = dis;
        p[a][b] = p[b][a] = pri;
    }
    scanf("%d%d", &s, &t);
}

int main()
{
    while(scanf("%d%d", &n, &m) != EOF)
    {
        if(m == 0 && n == 0) break;
        init();
        input();
        dijkstra();
        printf("%d %d\n", dd[t], pp[t]);
    }
    return 0;
}
```


输入：邻接矩阵

测试数据： 

6

0 6 3 0 0 0

0 0 0 5 0 0

0 2 0 3 4 0

0 0 0 0 2 3

0 0 0 0 0 5

0 0 0 0 0 0

```c
//1. 标记起始节点为已访问 
//2. 找最邻近节点 标记为已访问
//3. 更新源点到其他点的路径
//4. 直到所有节点都被标记
//5. 找到了源点到所有点的最短路径 
#include<iostream>
using namespace std;
#define Max 0xfffffff

int n;
int map[1000 + 1][1000 + 1]; 
int visited[1000 + 1];
int d[1000 + 1];
int times = 1;

void print_d()
{
	cout << "times :" << times << endl;
	times ++;
	for(int i = 1; i <= n; i ++)
		if(d[i] != Max) cout << d[i] << " ";
		else cout << "Max ";
	cout << endl; 
}

void print_visited()
{
	cout << "visited :" <<endl;
	for(int i = 1; i <= n; i ++)
		cout << visited[i] << " "; 
	cout << endl;
}

void Dijkstra(int x) //从这里看，核心 
{
	int i, j, Min, p;
	for(i = 1; i <= n; i ++)
	{
		d[i] = map[x][i];
	}
	visited[x] = 1; //1 
	d[x] = 0;
	for(int i = 1; i < n; i ++) //2
	{
		Min = Max;
		for(j = 1; j <= n; j ++)
			if(!visited[j] && d[j] < Min)
			{
				p = j;
				Min = d[j];
			}
		visited[p] = 1;
		
		for(j = 1; j <= n; j ++) //3
		{
			if(!visited[j] && Min + map[p][j] < d[j]) //Min==d[p]
				d[j] = Min + map[p][j];
		}
		print_d();
		print_visited();
	}
	cout << "Result :" << endl;
	for(int i = 1; i <= n; i ++)
		cout << d[i] << " ";
	cout << endl;
}

void init() //初始化读入邻接矩阵 
{
	cin >> n;
	int i, j;
	for(int i = 1; i <= n; i ++)
	{
		for(int j = 1; j <= n; j ++)
		{
			cin >> map[i][j];
			if(map[i][j] == 0)
				map[i][j] = Max;
		}
	}
}

int main()
{
	init();
	Dijkstra(1);
	return 0;
}
```

### 题目1341：艾薇儿的演唱会(40分)
时间限制：1 秒内存限制：32 兆特殊判题：否提交：686解决：311
题目描述：
艾薇儿今天来到了中国，她计划两天后在哈尔滨举行一场个人的演唱会。由于出现了紧急情况，演唱会的举办方要求艾薇儿提前举行演唱会。艾薇儿现在在北京，她需要找出一条从北京到哈尔滨耗时最短的线路，以便尽快到达哈尔滨。
 中国的铁路线非常复杂，有很多条路线可以从北京到达哈尔滨。艾薇儿在网上找到了铁路线各个线路上所需花费的时间，但是她还是看不出来哪一条线路可以最快地到达哈尔滨。你有办法帮助艾薇儿找出从北京到哈尔滨所需的最短时间吗？找出来的人可以免费获得现场演唱会门票一张哦。
输入：
 输入的第一行包括一个整数N(2<=N<=100)，代表艾薇儿手上拿到的设有铁路站点的城市的个数，其中城市从1到n进行编号。以及M(1<=M<=1000)，代表有M条铁路线路，每条铁路线路只连接两个城市。
 接下来的一行有两个数，a和b(1<=a,b<=N)，分别表示北京和哈尔滨的编号。
 接下来有M行，每行有三个数x,y(1<=x,y<=N),t(1<=t<=1000),表示从城市x到城市y所需时间为t。
输出：
 请输出艾薇儿从北京到哈尔滨最少需要多长时间。你可以放心地认为肯定存在一条路线可以从北京到哈尔滨。
样例输入：
3 4
1 3
1 2 1
3 2 3
2 3 4
3 1 8
样例输出：
4
提示：
 1.火车能从城市x到城市y，就能从城市y到城市x，并且同一列火车来回所花费的时间是一样的。如果在x和y之间有不止一辆火车通行，则不同火车从x到y或者从y到x所花费的时间可能不相同。
 2.虽然城市数有N个，但不保证所有的城市都能互相到达。可以保证的是，从北京到哈尔滨一定会有一条通路。

- 注意
  初始化需要在输入n之后，因此init()的位置很重要。

- 代码
```c++
#include<stdio.h>
#define MAX 1010
#define INF 0x3f3f3f3f

int n, m, s, e;

int map[MAX][MAX];

int d[MAX], visited[MAX];


void init()
{
    for(int i = 1; i <= n; i ++)
    {
        d[i] = INF;
        visited[i] = 0;
        for(int j = 1; j <= n; j ++)
        {
            map[i][j] = map[j][i] = INF;
        }
    }
}

void input()
{
    scanf("%d%d", &n, &m);
    scanf("%d%d", &s, &e);
    init(); 
    for(int i = 0; i < m; i ++)
    {
        int x, y, t;
        scanf("%d%d%d", &x, &y, &t);
        if(t < map[x][y])
            map[x][y] = map[y][x] = t;
    }
}

void print_visited()
{
    for(int i = 1; i <= n; i ++) printf("%d ", visited[i]);
    printf("\n");
}

void print_d()
{
    for(int i = 1; i <= n; i ++) printf("%d ", d[i]);
    printf("\n");
}

void dijkstra()
{
    d[s] = 0;
    for(int i = 1; i <= n; i ++)
    {
        int k = -1;
        int Min = INF;
        for(int j = 1; j <= n; j ++)
        {
            if(!visited[j] && d[j] < Min)
            {
                k = j;
                Min = d[j];
            }
        }
        if(k == -1) break;
        visited[k] = 1;
        for(int j = 1; j <= n; j ++)
        {
            if(!visited[j] && d[k] + map[k][j] < d[j])
            {
                d[j] = d[k] + map[k][j];
            }
        }
    }
}


int main()
{
    input();
    dijkstra();
    printf("%d\n", d[e]);
}
```



## Huffman编码

# ----------【高精度】----------
## N!
Problem Description
Given an integer N(0 ≤ N ≤ 10000), your task is to calculate N!

 

Input
One N in one line, process to the end of file.

 

Output
For each N, output N! in one line.

 

Sample Input
1
2
3

 

Sample Output
1
2
6

 

Author
JGShining（极光炫影）


高精度问题：大整数乘法的应用
其核心思想就是把计算结果每一位上的数字保存到一个数组成员中，例如：
把124保存至数组中，保存结果应该是result[0] =4；result[1] =2；result[2] =1
把整个数组看成一个数字，这个数字和一个数相乘的时候，需要每一位都和这个乘数进行相乘运算还需要把前一位的进位加上。

写法如下：int 结果 = result[x] * 乘数 + 进位;
每一位的计算结果有了，把这个结果的个位数拿出来放到这个数组元素上：result[x] = 结果%10;
接下来的工作就是计算出进位：进位 = 结果 / 10;
这样一位一位的把整个数组计算一遍，最后可能还有进位，用同样的方法，把进位的数值拆成单个数字，放到相应的数组元素中。最后从后往前输出结果。

 ```c++
#include<stdio.h>
#define MAX 10000

int main()
{
	int n, p, temp;
	int ans[MAX];
	while(scanf("%d", &n) != EOF)
	{
		ans[0] = 1;
		p = 1; //the length of the data 
		for(int i = 1; i <= n; i ++)
		{
			int carry = 0;
			for(int j = 0; j < p; j ++)
			{
				temp = ans[j] * i + carry;
				ans[j] = temp % 10;
				carry = temp / 10;
			}
			while(carry)
			{
				ans[p ++] = carry % 10;
				carry /= 10;
			}
		}
		for(int i = p - 1; i >= 0; i --)
		{
			printf("%d", ans[i]);
		}
		printf("\n");
	}
	return 0;
}
 ```

# ----------【排序】----------

![273973-19cf4a1e58b6ebaf](C:\Users\bob\Pictures\273973-19cf4a1e58b6ebaf.png)

## 冒泡排序

- 算法思想

  通过==相邻元素==的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。

- 举例

对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6。3和4无需交换。5和3交换，变成3,5,4,8,6,3。这样一次冒泡就完了，把最小的数3排到最前面了。

- 复杂度：O(n^2)


- 实现代码

```c
void bubbleSort(int len, int a[])
{
	int i, j, t;
	for(i = 0; i < len - 1; i ++)
	{
		for(j = len - 1; j >= i; j --)
		{
			if(a[j - 1] > a[j])
			{
				t = a[j - 1];
				a[j - 1] = a[j];
				a[j] = t;
			}
		}
	}
}
```
## 选择排序

- 算法思想

  选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。

- 举个栗子

    对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。

- 复杂度 ：O(n^2)

- 实现代码

  ```c
  void selectionSort(int len, int a[])
  {
  	int i, j, smallest, t;
  	for(int i = 0; i < len - 1; i ++)
  	{
  		smallest = i; //最小元素位置 
  		for(j = i + 1; j < len; j ++)
  		{
  			if(a[j] < a[smallest])
  				smallest = j;
  		}
  		t = a[i];
  		a[i] = a[smallest];
  		a[smallest] = t;
  	}
  }
  ```

  ​

## 快速排序

- 算法思想

  通过一趟排序把数据分割成独立的两部分，其中一部分的数据比另外一部分的数据要小。然后再按此方法将两部分分别快速排序。整个排序过程可以递归进行，以此达到整个数据变成有序序列。

  快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。冒泡排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。

- 举例说明

  对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。

  ​

  上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以==最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小==	。所以j指针先移动才能先找到比基准数小的数。

- 复杂度 
  快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)，最坏是O(n^2)---当数组已经有序。


- STL 

```c
#include<algorithm> 
using namespace std; 
int a[5] = {1,3,6,2,5}; 
sort(a, a + 5); 
```

这时a就是升序排列的了。

- 实现代码

  ```c
  int partition(int a[], int start, int end)
  {
  	if(start < end)
  	{
  		int i = start, j = end, index_value = a[start], t; //index_value为枢纽元素的值
  		while(i < j)
  		{
  			while(i < j && a[j] >= index_value)
  			{
  				j --;
  			}
  			while(i < j && a[i] <= index_value)
  			{
  				i ++;
  			}
  			if(i < j)
  			{
  				t = a[i];
  				a[i] = a[j];
  				a[j] = t;
  			}
  		}
  		t = a[j];
  		a[j] = a[start];
  		a[start] = t;
  		return j;
  	}
  }

  void quickSort(int a[], int start, int end)
  {
  	if(start < end) //很重要
  	{
  		int index = partition(a, start, end); //index 记录枢轴元素的正确位置
  		quickSort(a, start, index - 1);
  		quickSort(a, index + 1, end);
  	}
  }
  ```

## 插入排序

- 算法思想

升序：将数组分为已排序和未排序两部分，每次取出一个未排序的数值，和已排序的数字进行比较，如果前面的数字大于未排序数值，则将其后移一个。最后把未排序数字放在合适的位置。

- 举例

  ![新文档 2017-08-08_1](C:\Users\bob\Documents\Tencent Files\836437409\FileRecv\MobileFile\新文档 2017-08-08_1.jpg)


- 实现代码

```c
void insertSort(int n, int a[]) //升序 
{
	int i, j; //i是未排序的值的下标，j是小于等于当前未排序值的值的下标 
	int x;
	for(i = 1; i < n; i ++) //遍历所有未排序的下标 
	{
		x = a[i]; //取出待排序元素的值
		j = i - 1; //令j从i的前一个开始倒序查找
		while(j >= 0 && a[j] > x)
		{
			a[j + 1] = a[j];
			j --;
		}
		a[j + 1] = x;
	}
}
```

- 复杂度

  看while中的比较次数，最坏情况：**已经有序**，需要比较的次数最多。
  $$
  \sum_{i = 1}^{n - 1}(i-1) = \frac{n(n-1)}{2}​
  $$















































































# ----------【贪心】----------

## OpenJudge 8469：特殊密码锁

http://noi.openjudge.cn/ch0406/8469/

- 总时间限制: 

  1000ms

- 内存限制: 

  1024kB


- 描述

  有一种特殊的二进制密码锁，由n个相连的按钮组成（n<30），按钮有凹/凸两种状态，用手按按钮会改变其状态。然而让人头疼的是，当你按一个按钮时，跟它相邻的两个按钮状态也会反转。当然，如果你按的是最左或者最右边的按钮，该按钮只会影响到跟它相邻的一个按钮。当前密码锁状态已知，需要解决的问题是，你至少需要按多少次按钮，才能将密码锁转变为所期望的目标状态。

- 输入

  两行，给出两个由0、1组成的等长字符串，表示当前/目标密码锁状态，其中0代表凹，1代表凸。

- 输出

  至少需要进行的按按钮操作次数，如果无法实现转变，则输出impossible。

- 样例输入

  011000

- 样例输出

  `1`

- ==思路==：
  首先思考枚举法，每个按钮有2种状态，但是最多可能有30个灯，因此状态有2^30之多，穷举一定会超时。

==重点1== 
一个灯只有按或者不按两种情况，不存在一个灯要开关多次的情况。一个灯如果按了第二下，就会抵消上一次按下所产生的影响。

例如八个灯 00000000 
按1后 11000000 
按3后 10110000 
按1后 01110000 
这和八个灯 00000000 
只按一次3后 01110000 
是完全相同的情况

==重点2==
我们只需要考虑是否按下第一个灯。因为如果第一个灯的状态被确定了，那么是否按下第二个灯也就决定了（如果第一个灯与期望不同，则按下，如果期望相同，则不按下）同理，第三个灯是否按下也唯一确定。

==贪心策略==
保证前面的都匹配，对于位置i，如果不匹配，就按下i+1位置的按钮（这样可以保证i位置前面的正确），最后判一下是否匹配即可。 
另外，对于0位置是否修改需要再讨论，所以这个贪心要跑两次。

所以，本题只要分两种情况：灯0被按下和没有被按下 
之后使用for循环判断别的灯是否需要按下即可 
当循环结束，若现在的灯况与答案相同，则输出两种方案中按键次数最少的，若不同，则impossible！

- 代码

  ```c++
  #include<stdio.h>
  #include<string.h>
  #include<algorithm>
  #define N 40
  #define MAX 1e9
  using namespace std;

  char s1[N], s2[N], t[N];

  int n;

  void click(int i)
  {
      s1[i - 1] = s1[i - 1] == '0' ? '1' : '0';
      s1[i] = s1[i] == '0' ? '1' : '0';
      if(i + 1 < n) s1[i + 1] = s1[i + 1] == '0' ? '1' : '0';
  }

  int main()
  {
      int i, ans, ans1 = MAX, ans2 = MAX, temp = 0; // -1 is no answer
      scanf("%s%s", s1, s2);
      n = strlen(s1);
      strcpy(t, s1);
      //do not click the 0th
      for(i = 1; i < n; i ++)
      {
          if(s1[i - 1] != s2[i - 1])
          {
              click(i);
              temp ++;
          }
      }
      if(s1[n - 1] == s2[n - 1])
          ans1 = temp;
      //click the 0th, here temp = 1
      temp = 1;
      strcpy(s1, t);
      s1[0] = s1[0] == '0' ? '1' : '0';
      s1[1] = s1[1] == '0' ? '1' : '0'; //change because click 0th
      for(i = 1; i < n; i ++)
      {
          if(s1[i - 1] != s2[i - 1])
          {
              click(i);
              temp ++;
          }
      }
      if(s1[n - 1] == s2[n - 1])
          ans2 = temp;
      ans = min(ans1, ans2);
      if(ans == MAX) puts("impossible");
      else printf("%d\n", ans);
      return 0;
  }

  ```

  ​

# ----------【搜索】----------

## 枚举

枚举所有情况即可，注意**时间**空间复杂度。

### 题目1059：abc

时间限制：1 秒内存限制：32 兆特殊判题：否提交：5283解决：4160
题目描述：
设a、b、c均是0到9之间的数字，abc、bcc是两个三位数，且有：abc+bcc=532。求满足条件的所有a、b、c的值。
输入：
题目没有任何输入。
输出：
请输出所有满足题目条件的a、b、c的值。
a、b、c之间用空格隔开。
每个输出占一行。
样例输入：
样例输出：
来源：
2000年清华大学计算机研究生机试真题

```c
#include<stdio.h>

int main()
{
	int a, b, c;
	for(a = 1; a <= 9; a ++)
		for(b = 1; b <= 9; b ++)
			for(c = 0; c <= 9; c ++)
			{
				if(2*c + 10*(b + c) + 100*(a + b) == 532)
					printf("%d %d %d\n", a, b, c);
			}
	return 0;
} 
```

### 题目1036：Old Bill

时间限制：1 秒内存限制：32 兆特殊判题：否提交：3780解决：2064
题目描述：

```
Among grandfather's papers a bill was found.
72 turkeys $_679_
The first and the last digits of the number that obviously represented the total price of those turkeys are replaced here by blanks (denoted _), for they are faded and are illegible. What are the two faded digits and what was the price of one turkey?
We want to write a program that solves a general version of the above problem.
N turkeys $_XYZ_
The total number of turkeys, N, is between 1 and 99, including both. The total price originally consisted of five digits, but we can see only the three digits in the middle. We assume that the first digit is nonzero, that the price of one turkeys is an integer number of dollars, and that all the turkeys cost the same price.
Given N, X, Y, and Z, write a program that guesses the two faded digits and the original price. In case that there is more than one candidate for the original price, the output should be the most expensive one. That is, the program is to report the two faded digits and the maximum price per turkey for the turkeys.
```

输入：

```
The first line of the input file contains an integer N (0<N<100), which represents the number of turkeys. In the following line, there are the three decimal digits X, Y, and Z., separated by a space, of the original price $_XYZ_.
```

输出：

```
For each case, output the two faded digits and the maximum price per turkey for the turkeys.
```

样例输入：

```72
6 7 9
5
2 3 7
78
0 0 5
```

样例输出：

```
3 2 511
9 5 18475
0
```

来源：
2007年上海交通大学计算机研究生机试真题

```c
#include<stdio.h>

int main()
{
	int n, x, y, z, first, last, sum;
	while(scanf("%d", &n) != EOF)
	{
		int flag = 0;
		scanf("%d%d%d", &x, &y, &z);
		for(first = 9; first >= 1 && flag == 0; first --)
		{
			for(last = 9; last >= 0 && flag == 0; last --)
			{
				sum = (last + 10*z + 100*y + 1000*x + 10000*first);
				if(sum % n == 0)
				{
					printf("%d %d %d\n", first, last, sum/n);
					flag = 1;
				}		
			}
		}
		if(flag == 0) printf("0\n");
	}
	return 0;
} 
```

注意：上面flag判断条件加在了两个for循环中，break只能跳出当前for循环。

## BFS

先明确查找空间、查找目标、查找方法。将初始状态视为根节点，并将每一个状态扩展得到新的状态视为该状态的儿子节点，那么状态的转移与生成就呈现出了树的形态。将包含搜索空间中所有状态的树称为解答树，采用的搜索方法就是对解答树遍历的方法。

BFS第一次查找到解状态，其记录的时间或者走过的路径是最少的。

限制状态的无限扩展——剪枝。

### 题目1456：胜利大逃亡

**时间限制：**1 秒

**内存限制：**128 兆

**特殊判题：**否

**提交：**4478

**解决：**1633

- **题目描述：**

  Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.魔王住在一个城堡里,城堡是一个A*B*C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.


- **输入：**

  输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1<=A,B,C<=50,1<=T<=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块......),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙。


- **输出：**

  对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.


- **样例输入：**

  `13 3 4 200 1 1 10 0 1 10 1 1 11 1 1 11 0 0 10 1 1 10 0 0 00 1 1 00 1 1 0 `


- **样例输出：**

  `11`

```c

```




###题目1335：闯迷宫
时间限制：1 秒内存限制：32 兆特殊判题：否提交：2464解决：658
题目描述：
sun所在学校每年都要举行电脑节，今年电脑节有一个新的趣味比赛项目叫做闯迷宫。
sun的室友在帮电脑节设计迷宫，所以室友就请sun帮忙计算下走出迷宫的最少步数。
知道了最少步数就可以辅助控制比赛难度以及去掉一些没有路径到达终点的map。
比赛规则是：从原点（0,0）开始走到终点（n-1,n-1），只能上下左右4个方向走，只能在给定的矩阵里走。
输入：
输入有多组数据。
每组数据输入n（0<n<=100），然后输入n*n的01矩阵，0代表该格子没有障碍，为1表示有障碍物。
注意：如果输入中的原点和终点为1则这个迷宫是不可达的。
输出：
对每组输入输出该迷宫的最短步数，若不能到达则输出-1。
样例输入：
2
0 1
0 0
5
0 0 0 0 0
1 0 1 0 1
0 0 0 0 0
0 1 1 1 0
1 0 1 0 0
样例输出：
2
8

- 思路:
  经典BFS, 广搜需要用队列！！！

- 代码：
```c++
#include<stdio.h>
#include<string.h>
#include<queue>
#define MAX 110
using namespace std;

int n;
int a[MAX][MAX];

struct Node
{
    int x;
    int y;
    int s;
};

queue<Node> que;

int dir[4][2] =
{
	0, 1,
	0, -1,
	-1, 0,
	1, 0
};

void clearQue()
{
    while(!que.empty()) que.pop();
}

int hasRoad(int x, int y)
{
	if (x >= 0 && x < n && y >= 0 && y < n)
		if(a[x][y] == 0)
			return 1;
	return 0;
}

int bfs()
{
    if(a[0][0] == 1 || a[n - 1][n - 1] == 1) return -1; //Error: put this sentence into the while cycle and the visited a[][] will be marked 1
    while(!que.empty())
    {
        Node p = que.front();
        que.pop();
        if(p.x == n - 1 && p.y == n - 1) return p.s;

        for(int i = 0; i < 4; i ++)
        {
            int n_xx = p.x + dir[i][0];
            int n_yy = p.y + dir[i][1];
            if(hasRoad(n_xx, n_yy))
            {
                Node t;
                a[n_xx][n_yy] = 1;
                t.x = n_xx;
                t.y = n_yy;
                t.s = p.s + 1;
                que.push(t);
            }
        }
    }
    return -1;
}

int main()
{
    //freopen("in3.txt", "r", stdin);
	while (scanf("%d", &n) != EOF)
	{
	    clearQue();
		memset(a, -1, sizeof(a));
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++)
				scanf("%d", &a[i][j]);
        Node start;
        start.x = 0;
        start.y = 0;
        start.s = 0;
        que.push(start);
		printf("%d\n", bfs());
	}
	return 0;
}
```














## DFS

http://blog.csdn.net/saltriver/article/details/54429068
### Oil Deposits
Oil Deposits
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 3087    Accepted Submission(s): 1765
Problem Description
The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.
 
Input
The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 <= m <= 100 and 1 <= n <= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either `*', representing the absence of oil, or `@', representing an oil pocket.

Output
For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.

 
Sample Input
1 1
*
3 5
*@*@*
**@**
*@*@*
1 8
@@****@*
5 5 
****@
*@@*@
*@**@
@@@*@
@@**@
0 0 
 
Sample Output
0
1
2
2
```c++
#include<iostream>
#define MAX 110
using namespace std;

char a[MAX][MAX];
int m, n;

void dfs(int i, int j)
{
	//not accessable, return  
	if(i < 1 || i > m || j < 1 || j > n || a[i][j] != '@') 
		return;
	//else, mark this point as visited and dfs to the eight direction
	else
	{
		a[i][j] = 'v';
		dfs(i - 1, j);
		dfs(i + 1, j);
		dfs(i, j - 1);
		dfs(i, j + 1);
		dfs(i - 1, j - 1);
		dfs(i + 1, j - 1);
		dfs(i - 1, j + 1);
		dfs(i + 1, j + 1);
	}
}

int main()
{
	while(cin >> m >> n)
	{
		if(m == 0) break;
		int sum = 0;
		for(int i = 1; i <= m; i ++)
			for(int j = 1; j <= n; j ++)
			{
				cin >> a[i][j]; //scanf %c will not easy to use
			}
				
		for(int i = 1; i <= m; i ++)
			for(int j = 1; j <= n; j ++)
			{
				if(a[i][j] == '@')
				{
					dfs(i, j);
					sum ++;
				}	
			}
		cout << sum << endl;
	}
	return 0;
}
```

# ----------【模拟】----------

## 日期类问题

###  题目1096：日期差值	

**时间限制：**1 秒

**内存限制：**32 兆

**特殊判题：**否

**提交：**14440

**解决：**4827

- **题目描述：**

  有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天


- **输入：**

  有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD


- **输出：**

  每组数据输出一行，即日期差值


- **样例输入：**

  `2011041220110422`


- **样例输出：**

  `11`


- **来源：**

  [*2009年上海交通大学计算机研究生机试真题*](http://ac.jobdu.com/problemset.php?search=2009%E5%B9%B4%E4%B8%8A%E6%B5%B7%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%BA%E8%AF%95%E7%9C%9F%E9%A2%98)

  ```c
  #include<stdio.h>

  int isLeapYear(int x)
  {
  	return x % 4 == 0 && x % 100 != 0 || x % 400 == 0 ? 1 : 0; 
  }

  int dayOfMonth[13][2]
  {
  	0, 0,
  	31, 31,
  	28, 29,
  	31, 31,
  	30, 30,
  	31, 31,
  	30, 30,
  	31, 31,
  	31, 31,
  	30, 30,
  	31, 31,
  	30, 30,
  	31, 31
  };

  int dist[5010][13][32];

  int abs(int x)
  {
  	return x > 0 ? x : -x;
  }

  struct Date
  {
  	int year;
  	int month;
  	int day;
  	void nextDay()
  	{
  		day ++;
  		if(day > dayOfMonth[month][isLeapYear(year)])
  		{
  			day -= dayOfMonth[month][isLeapYear(year)];
  			month ++;
  			if(month > 12)
  			{
  				month = 1;
  				year ++;
  			}
  		}
  	}
  };

  int main()
  {
  	Date date;
  	date.year = 0;
  	date.month = 0;
  	date.day = 0;
  	int t = 0;
  	while(date.year != 5000)
  	{
  		dist[date.year][date.month][date.day] = t;
  		t ++;
  		date.nextDay();
  	}
  	int y1, m1, d1, y2, m2, d2;
  	while(scanf("%4d%2d%2d%4d%2d%2d", &y1, &m1, &d1, &y2, &m2, &d2) != EOF)
  	{
  		printf("%d\n", abs(dist[y1][m1][d1] - dist[y2][m2][d2]) + 1);
  	}
  	return 0;
  }
  ```




# ----------【STL】----------

## stringstream 数据类型转换

-  字符转数字

  ```c++
  #include<iostream>
  #include<string>
  #include<sstream>
  using namespace std;

  int main()
  {
  	stringstream stream;
  	char s[] = "1 22";
  	stream << s;
  	int ans;
  	while(stream >> ans)
  	cout << ans << endl;
  }
  ```

- 数字转字符

  ```c++
  #include<iostream>
  #include<sstream>
  #include<string>
  using namespace std;

  int main() //int to char
  {
  	stringstream stream;
  	string result;
  	int num = 1000;
  	stream << num;
  	stream >> result;
  	cout << result << endl;
  }
  ```

  ​

## vector不定长数组

```c++
#include<stdio.h>
#include<vector>
#include<algorithm>
using namespace std;

vector<int> v;
vector<int> ::iterator it;


void print()
{
    for(it = v.begin(); it != v.end(); it ++)
        printf("%d ", *it);
    printf("\n");
}

int main()
{
    v.push_back(5);
    v.push_back(6);
    v.push_back(7);
    //output
    print();
    //printf("%d %d", v[0], v[1]);

    //reverse algorithm
    reverse(v.begin(), v.end());
    print();

    //pop
    v.pop_back();
    print();

    //size()
    printf("%d\n", v.size());

    //front and back element
    printf("front : %d end: %d\n", v.front(), v.back());


    v.clear();
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    v.push_back(5);
    print();

    //erase the second element
    v.erase(v.begin() + 1);
    print();
    v.erase(v.begin(), v.end()); //erase [begin, end)
    printf("%d\n", v.size());
}
```

**初始化及清零**

------

定义空二维vector，再赋值
vector<vector <int> > ivec(m ,vector<int>(n)); //m*n的二维vector，注意两个 "> "之间要有空格！

void assign(const_iterator first, const_iterator last);

void assign( size_type _Count, const Type& _Val ); // 赋值，用指定元素序列替换容器内所有元素

定义并初始化二维数组

vector<vector <int> > ivec(m ,vector<int>(n,0)); //m*n的二维vector，所有元素初始化为0
  ```
vector<string> v1;         // 创建空容器，其对象类型为string类

  ```

​```c++
vector<string> v2(10);     // 创建有10个具有初始值（即空串）的string类对象的容器

vector<string> v3(5, "hello"); // 创建有5个值为“hello”的string类对象的容器

vector<string> v4(v3.begin(), v3.end());  // v4是与v3相同的容器（完全复制）
```c

http://blog.csdn.net/xiaxiazls/article/details/50018225

​```c++
#include<stdio.h>
#include<vector>

using namespace std;

int main()
{
	vector<int> a;
	a.push_back(5);
	a.push_back(6); 
	printf("a[0] = %d, size = %d\n", a[0], a.size());
	a.pop_back();
	for(int i = 0; i < a.size(); i ++)
		printf("%d ", a[i]);
	return 0;
}
```

## string 字符串

```c++
#include<string>
#include<stdio.h>
#include<iostream>
using namespace std;

string s;

void print(string s)
{
    cout << s << endl;
}

int main()
{
    char str[100];
    gets(str);
    s = str;

    s = "abcdefg";
    print(s);

    s += 'h';
    print(s);

    string s1 = "Abc";
    string s2 = "ab";
    if(s1 > s2) print(s1);
    else print(s2); //ab

    for(int i = 0; i < s.size(); i ++)
        printf("%c ", s[i]);

    return 0;
}

```



## stack 栈

[C++](http://lib.csdn.net/base/cplusplus)stack(堆栈）是一个容器的改编，它实现了一个先进后出的[数据结构](http://lib.csdn.net/base/datastructure)（FILO）

使用该容器时需要包含#include<stack>头文件；

定义stack对象的示例代码如下：

stack<int>s1;

stack<string>s2;

stack的基本操作有：

1.入栈：如s.push(x);

2.出栈:如 s.pop().注意：出栈操作只是删除栈顶的元素，并不返回该元素。

3.访问栈顶：如s.top();

4.判断栈空：如s.empty().当栈空时返回true。

5.访问栈中的元素个数，如s.size（）;

```c++
#include<stdio.h>
#include<stack>
using namespace std;

int main()
{
	stack<double> s;
	for(int i = 0; i < 10; i ++)
		s.push(i);
	while(!s.empty())
	{
		printf("%lf ", s.top());
		s.pop();
	}
	printf("the size of stack: %d\n", s.size());
	return 0;
} 
```

## queue 队列

### 队列

定义queue对象的示例代码如下：

queue<int>q1;

queue<double>q2;

queue的基本操作有：

1.入队：如q.push(x):将x元素接到队列的末端；

2.出队：如q.pop() 弹出队列的第一个元素，并不会返回元素的值；

3,访问队首元素：如q.front()

4,访问队尾元素，如q.back();

5,访问队中的元素个数，如q.size();

```c
#include <cstdlib>
#include <iostream>
#include <queue>
  
using namespace std;
  
int main()
{
    int e,n,m;
    queue<int> q1;
    for(int i=0;i<10;i++)
       q1.push(i);
    if(!q1.empty())
    cout<<"dui lie  bu kong\n";
    n=q1.size();
    cout<<n<<endl;
    m=q1.back();
    cout<<m<<endl;
    for(int j=0;j<n;j++)
    {
       e=q1.front();
       cout<<e<<" ";
       q1.pop();
    }
    cout<<endl;
    if(q1.empty())
    cout<<"dui lie  bu kong\n";
    system("PAUSE");
    return 0;
}
```

### 优先队列

在<queue>头文件中，还定义了一个非常有用的模版类priority_queue(优先队列），优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。

priority_queue模版类有三个模版参数，元素类型，容器类型，比较算子。其中后两个都可以省略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队时序列尾的元素出队）。

定义priority_queue对象的示例代码如下：

priority_queue<int >q1;

priority_queue<pair<int,int> >q2;

**priority_queue<int,vector<int>，greater<int> >q3;//定义小的先出队**

priority_queue的基本操作均与queue相同

初学者在使用priority_queue时，最困难的可能就是如何定义比较算子了。如果是基本数据类型，或已定义了比较运算符的类，可以直接用STL的less算子和greater算子——默认为使用less算子，即小的往前排，大的先出队。如果要定义自己的比较算子，方法有多种，这里介绍其中的一种：重载比较运算符。优先队列试图将两个元素x和y代入比较运算符(对less算子，调用x<y，对greater算子，调用x>y)，若结果为真，则x排在y前面，y将先于x出队，反之，则将y排在x前面，x将先出队。

```c++
#include<iostream>  
#include<queue>  
#include<stdlib.h>  
using namespace std;  
class T  
{  
public:  
    int x,y,z;  
    T(int a,int b,int c):x(a),y(b),z(c)  
    {  
    }  
};  
bool operator<(const T&t1,const T&t2)  
{  
    return t1.z<t2.z;  
}  
int main(void)  
{  
    priority_queue<T>q;  
    q.push(T(4,4,3));  
    q.push(T(2,2,5));  
    q.push(T(1,5,4));  
    q.push(T(3,3,6));  
    while(!q.empty())  
    {  
        T t=q.top();  
        q.pop();  
        cout<<t.x<<" "<<t.y<<" "<<t.z<<endl;  
    }  
    system("Pause");  
    return 1;  
}  
```

### 1172哈夫曼树 【优先队列】
- 题目
  题目1172：哈夫曼树
  时间限制：1 秒内存限制：32 兆特殊判题：否提交：11513解决：5237
  题目描述：
  哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有结点的值与权值的乘积之和。
  输入：
  输入有多组数据。
  每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2<=n<=1000）。
  输出：
  输出权值。
  样例输入：
  5  
  1 2 2 5 9
  样例输出：
  37
  来源：
  2010年北京邮电大学计算机研究生机试真题

- 思路
1. 数据结构 优先队列（小权值优先）每次选取最小的两个出队合并成为新的节点然后入队

2. 所有结点的值与权值的乘积之和：（不是很准确）
  节点的值表示权值，从根到该节点的路径长度*该节点权值 = 带权路径长度

  此处有推导公式：http://blog.csdn.net/hchild1/article/details/50933972

  其实就是非叶节点的值之和。

3. 注意：
  priority_queue< int, vector<int>, greater<int> > Q; //novel有空格
  注意每次要清空队列

- 代码
```c++
#include<stdio.h>
#include<queue>
using namespace std;

priority_queue< int, vector<int>, greater<int> > Q; //novel

int main()
{
    int n;
    while(scanf("%d", &n) != EOF)
    {
        while(!Q.empty()) Q.pop(); //Error: forget clear the queue
        int x;
        for(int i = 0; i < n; i ++)
        {
            scanf("%d", &x);
            Q.push(x);
        }
        int ans = 0;
        while(Q.size() > 1) //Error: !Q.empty() 循环结束条件：当队列中仅剩下一个节点。（根节点）
        {
            int a = Q.top();
            Q.pop();
            int b = Q.top();
            Q.pop();
            Q.push(a + b);
            ans += (a + b);
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

## sort快速排序

```c++
#include<stdio.h>
#include<vector>
#include<algorithm>

using namespace std;

bool cmp(const int &a, const int &b)
{
	return a > b;
}

int main()
{
	vector<int> v;
	v.push_back(1);
	v.push_back(5);
	v.push_back(4);
	v.push_back(9);
	sort(v.begin(), v.end(), cmp);
	for(int i = 0; i < v.size(); i ++)
		printf("%d ", v[i]);
	return 0;
} 

//对于结构体排序：
struct ss
{
    int a,b;
};
bool comp(const ss &a,const ss &b)
{
    return a.a<b.a;
}
```

## map

http://www.cplusplus.com/reference/map/map/?kw=map

### 题目1010：A + B

**时间限制：**1 秒

**内存限制：**32 兆

**特殊判题：**否

**提交：**9151

**解决：**4729

- **题目描述：**

  读入两个小于100的正整数A和B,计算A+B.需要注意的是:A和B的每一位数字由对应的英文单词给出.


- **输入：**

  测试输入包含若干测试用例,每个测试用例占一行,格式为"A + B =",相邻两字符串有一个空格间隔.当A和B同时为0时输入结束,相应的结果不要输出.


- **输出：**

  对每个测试用例输出1行,即A+B的值.


- **样例输入：**

  `one + two =three four + five six =zero seven + eight nine =zero + zero =`


- **样例输出：**

  `39096`


- **来源：**

  [*2005年浙江大学计算机及软件工程研究生机试真题*](http://ac.jobdu.com/problemset.php?search=2005%E5%B9%B4%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%BA%E8%AF%95%E7%9C%9F%E9%A2%98)

- 代码

  ```c++
  #include <iostream>
  #include <string>
  #include <map>
  using namespace std;

  int main()
  {
      map<string,int> m;
      m["zero"]=0;
      m["one"]=1;
      m["two"]=2;
      m["three"]=3;
      m["four"]=4;
      m["five"]=5;
      m["six"]=6;
      m["seven"]=7;
      m["eight"]=8;
      m["nine"]=9;
      
      int a,b;
      string s1,s2;
      
      while(1)
      {
          cin>>s1>>s2;
          if("+" == s2)
              a = m[s1];
          else
              a = m[s1]*10 + m[s2], cin>>s2;
          cin>>s1>>s2;
          if("=" == s2)
              b = m[s1];
          else
              b = m[s1]*10 + m[s2], cin>>s2;
          if(0 == a+b)
              break;
          cout<<a+b<<endl;
      }
      return 0;
  }
  ```


### POJ G:双队列
http://www.bailian.openjudge.cn/dsj2017xly/G/

总时间限制: 1000ms 内存限制: 65536kB
描述
系统A用来维护客户。每个客户的id用一个正整数K来表示，当客户进入系统时用P来表示此用户的优先度。这个系统有以下请求
0
系统停止运行
1 K P
优先度为P的客户K进入系统
2
找到优先度最高的客户，然后此客户离开系统
3
找到优先度最低的客户，然后此客户离开系统
输入
每行包括一个请求，最后一行包括一个停止请求(代码0)。对于添加客户请求(代码1)，优先度都是唯一的。客户的表示K小于106，优先度P小于107，一个客户可能会被添加多次，每次的优先度可能不同。
输出
对于每个请求2和3，程序必须输出一行。这行包括此请求中找到客户的id。如果系统中没有客户，输出0
样例输入
2
1 20 14
1 30 3
2
1 10 99
3
2
2
0
样例输出
0
20
30
10
0

- 思路：利用map的根据第一个值升序的特点进行
```c++
#include<iostream>  
#include<map>  
#include<cstdio>  
#include<algorithm>  
using namespace std;  
  
map<int, int>c;  
  
int main()  
{  
    int op;  
    while (scanf("%d",&op)&&op)  
    {  
        if (op == 1)  
        {  
            int a, b;  
            scanf("%d%d", &a, &b);  
            c[b] = a;  
        }  
        else if (op == 2)  
        {  
            if (c.empty())   
                cout << 0 << endl;  
            else  
            {  
                cout << c.rbegin()->second << endl;             //rbegin返回逆向迭代器，指向最后一个元素，rend指向第一个元素的前一个位置           
                c.erase(c.rbegin()->first);  
            }                                                   //遍历依旧用it++；  
        }  
        else if (op == 3)  
        {  
            if (c.empty()) cout << 0 << endl;  
            else   
            {  
                cout << c.begin()->second << endl;  
                c.erase(c.begin()->first);  
            }  
        }  
  
    }  
  
}  
```
另：
```c++
#include<iostream>
#include<map>
using namespace std;

int main(){
    map<int,int> myMap;
    map<int,int>::iterator iter;//注意map的这种用法
    int n,K,P,sum=0;
    while(scanf("%d",&n)==1 && n!=0){
        if(n==1){
            //本题换作cin，cout超时了
            //cin>>K>>P;
            scanf("%d%d",&K,&P);
            myMap[P]=K;
            sum++;
        }
        if(n==2){
            if(sum==0){
                //cout<<0<<endl;
                printf("0\n");
            }
            else{
                iter=myMap.end();
                iter--;
                //cout<<iter->second<<endl;
                printf("%d\n",iter->second);
                myMap.erase(iter);
                sum--;
            }
        }
        if(n==3){
            if(sum==0){
                //cout<<0<<endl;
                printf("0\n");
            }
            else{
                iter=myMap.begin();
                //cout<<iter->second<<endl;
                printf("%d\n",iter->second);
                myMap.erase(iter);
                sum--;
            }
        }

    }
    return 0;
}
```

### POJ1002好题
487-3279
Time Limit: 2000MS		Memory Limit: 65536K
Total Submissions: 295301		Accepted: 52897
Description

Businesses like to have memorable telephone numbers. One way to make a telephone number memorable is to have it spell a memorable word or phrase. For example, you can call the University of Waterloo by dialing the memorable TUT-GLOP. Sometimes only part of the number is used to spell a word. When you get back to your hotel tonight you can order a pizza from Gino's by dialing 310-GINO. Another way to make a telephone number memorable is to group the digits in a memorable way. You could order your pizza from Pizza Hut by calling their ``three tens'' number 3-10-10-10. 

The standard form of a telephone number is seven decimal digits with a hyphen between the third and fourth digits (e.g. 888-1200). The keypad of a phone supplies the mapping of letters to numbers, as follows: 

A, B, and C map to 2 
D, E, and F map to 3 
G, H, and I map to 4 
J, K, and L map to 5 
M, N, and O map to 6 
P, R, and S map to 7 
T, U, and V map to 8 
W, X, and Y map to 9 

There is no mapping for Q or Z. Hyphens are not dialed, and can be added and removed as necessary. The standard form of TUT-GLOP is 888-4567, the standard form of 310-GINO is 310-4466, and the standard form of 3-10-10-10 is 310-1010. 

Two telephone numbers are equivalent if they have the same standard form. (They dial the same number.) 

Your company is compiling a directory of telephone numbers from local businesses. As part of the quality control process you want to check that no two (or more) businesses in the directory have the same telephone number. 

Input

The input will consist of one case. The first line of the input specifies the number of telephone numbers in the directory (up to 100,000) as a positive integer alone on the line. The remaining lines list the telephone numbers in the directory, with each number alone on a line. Each telephone number consists of a string composed of decimal digits, uppercase letters (excluding Q and Z) and hyphens. Exactly seven of the characters in the string will be digits or letters. 
Output

Generate a line of output for each telephone number that appears more than once in any form. The line should give the telephone number in standard form, followed by a space, followed by the number of times the telephone number appears in the directory. Arrange the output lines by telephone number in ascending lexicographical order. If there are no duplicates in the input print the line: 

No duplicates. 
Sample Input

12
4873279
ITS-EASY
888-4567
3-10-10-10
888-GLOP
TUT-GLOP
967-11-11
310-GINO
F101010
888-1200
-4-8-7-3-2-7-9-
487-3279
Sample Output

310-1010 2
487-3279 4
888-4567 3

- 思路
  利用map中的键有序特点

- 代码

  ```c++
  #include<stdio.h>
  #include<string.h>
  #include<map>
  using namespace std;

  map<int, int> m;
  map<int, int>::iterator iter;

  map<char, int> n;
  void init()
  {
  	n['A'] = n['B'] = n['C'] = 2;
  	n['D'] = n['E'] = n['F'] = 3;
  	n['G'] = n['H'] = n['I'] = 4;
  	n['J'] = n['K'] = n['L'] = 5;
  	n['M'] = n['N'] = n['O'] = 6;
  	n['P'] = n['R'] = n['S'] = 7;
  	n['T'] = n['U'] = n['V'] = 8;
  	n['W'] = n['X'] = n['Y'] = 9;
  }

  int getNum(char s[])
  {
  	int len = strlen(s), t = 1, ans = 0;
  	for(int i = len - 1; i >= 0; i --)
  	{
  		if(s[i] >= '0' && s[i] <= '9')
  		{
  			ans += (s[i] - '0') * t;
  			t *= 10;
  		}
  		else if(s[i] >= 'A' && s[i] <= 'Y')
  		{
  			ans += (n[ s[i] ] * t);
  			t *= 10;
  		}
  		
  	}
  	return ans;
  }

  void print()
  {
  	iter = m.begin();
  	int flag = 1;
  	while(iter != m.end())
  	{
  		if(iter -> second > 1)
  		{
  			printf("%03d-%04d %d\n", (iter -> first)/10000, (iter -> first)%10000, iter -> second);
  			flag = 0;
  		}
  		iter ++;
  	}
  	if(flag) printf("No duplicates.\n");
  }

  int main()
  {
  	int t;
  	init();
  	scanf("%d", &t);
  	while(t --)
  	{
  		char str[50];
  		scanf("%s", str);
  		int num = getNum(str);
  		iter = m.find(num);
  		if(iter == m.end()) m[num] = 1;
  		else m[num] = m[num] + 1;
  	}
  	print();
  	return 0;
  }
  ```

  ​



# ----------【字符串】----------

## 题目1006：ZOJ问题

**时间限制：**1 秒

**内存限制：**32 兆

**特殊判题：**否

**提交：**22919

**解决：**4110

- **题目描述：**

  对给定的字符串(只包含'z','o','j'三种字符),判断他是否能AC。是否AC的规则如下：1. zoj能AC；2. 若字符串形式为xzojx，则也能AC，其中x可以是N个'o' 或者为空；3. 若azbjc 能AC，则azbojac也能AC，其中a,b,c为N个'o'或者为空；


- **输入：**

  输入包含多组测试用例，每行有一个只包含'z','o','j'三种字符的字符串，字符串长度小于等于1000。


- **输出：**

  对于给定的字符串，如果能AC则请输出字符串“Accepted”，否则请输出“Wrong Answer”。


- **样例输入：**

  `zojozojoozoojoooozoojoooozoojozojooooozojozojoooo`


- **样例输出：**

  `AcceptedAcceptedAcceptedAcceptedAcceptedAcceptedWrong AnswerWrong Answer`

  ​

- 思路：

  由2推出3的过程中，即azbjc到azbojac ![新文档 2017-08-10_1](C:\Users\bob\Documents\Tencent Files\836437409\FileRecv\MobileFile\新文档 2017-08-10_1.jpg)

- 代码

  ```c
  #include<stdio.h>
  #include<string.h>
  #define bool int
  #define true 1
  #define false 0

  bool judge(char s[])
  {
  	int z_num = 0, j_num = 0, len = strlen(s);
  	int a = 0, b = 0, c = 0;
  	int tag1 = -1, tag2 = -1;
  	for(int i = 0; i < len; i ++)
  	{
  		if(s[i] == 'z')
  		{
  			tag1 = i;
  			z_num ++;
  		}
  		if(s[i] == 'j')
  		{
  			tag2 = i;
  			j_num ++;
  		}
  	}
  	if(tag1 >= tag2 || z_num * j_num != 1) return false;
  	a = tag1;
  	b = tag2 - tag1 - 1;
  	c = len - tag2 - 1;
  	if(c == a * b && b != 0) return true;
  	else return false;
  }

  int main()
  {
  	char s[1010];
  	while(scanf("%s", &s) != EOF)
  	{
  		if(judge(s)) printf("Accepted\n"); //不要写成Accept！
  		else printf("Wrong Answer\n");
  	}
  	return 0;
  }
  ```

- 总结

  1. c中没有bool
  2. 注意总结推导规律简化题目
  3. Accepted 不要写成 Accept 要仔细啊 太粗心了 


### 题目1019：简单计算器【stack】

**时间限制：**1 秒

**内存限制：**32 兆

**特殊判题：**否

**提交：**10461

**解决：**3829

- **题目描述：**

      读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。


- **输入：**

      测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。


- **输出：**

      对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。


- **样例输入：**

  1 + 2
  4 + 2 * 5 - 7 / 110


- **样例输出：**

  3.00
  13.36


- **来源：**

  [*2006年浙江大学计算机及软件工程研究生机试真题*](http://ac.jobdu.com/problemset.php?search=2006%E5%B9%B4%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%BA%E8%AF%95%E7%9C%9F%E9%A2%98)



- 特点：注意观察字符串特点 都是二元运算符 那么可以先读取一个数 然后按照 符号+空格+数字+空格的方式读取 遇到+号后面的数字存入栈 -号取反入栈 */号就和栈顶元素相乘除 然后给栈中所有元素求和

- 代码

  ```c
  #include<stdio.h>
  #include<string.h>
  int main()
  {
  	int a;
  	char blank;
  	while(scanf("%d", &a) != EOF && a != 0)
  	{
  		scanf("%c", &blank);//吸收第一个数字后面的空格
  		double stack[210];
  		int top = 0; //始终指向栈顶元素
  		stack[top] = (double)a;
  		char x1, x2;
  		int num;
  		while(scanf("%c %d%c", &x1, &num, &x2) != EOF)
  		{
  			if(x1 == '+') stack[++ top] = (double)num;
  			else if(x1 == '-') stack[++ top] = -(double)num;
  			else if(x1 == '*')
  			{
  				stack[top] *= (double)num;
  			} 
  			else if(x1 == '/')
  			{
  				stack[top] /= (double)num;
  			}
  			//printf("--stack: %f top : %d\n", stack[top], top);
  			if(x2 != ' ') break; //不能放在循环里
  		}
  		double ans = 0;
  		for(int i = 0; i <= top; i ++)
  			ans += stack[i];
  		printf("%.2lf\n", ans);
  	}
  	return 0;
  }
  ```

STL:

```c++
#include <iostream>
#include<stdio.h>
#include<string.h>
#include<stack>
using namespace std;

stack<double> myStack;

int main()
{
    int x, firstnum;
    char symbol, blank;
    while(scanf("%d", &firstnum) != EOF && firstnum != 0)
    {
        myStack.push(firstnum);
        scanf("%c", &blank); //吸收数字后面的空格
        while(scanf("%c %d%c", &symbol, &x, &blank) != EOF)
        {
            if(symbol == '+') myStack.push(x);
            else if(symbol == '-') myStack.push(-x);
            else if(symbol == '*') myStack.top() *= x;
            else if(symbol == '/') myStack.top() /= x;
            if(blank != ' ') break;
        }
        double ans = 0;
        while(!myStack.empty()) //想要遍历stack只能top() pop() 否则用数组模拟
        {
            ans += myStack.top();
            myStack.pop();
        }
        printf("%.2f\n", ans);
    }
    return 0;
}

```





### 题目1203：IP地址

**时间限制：**1 秒

**内存限制：**32 兆

**特殊判题：**否

**提交：**4074

**解决：**2013

- **题目描述：**

      输入一个ip地址串，判断是否合法。


- **输入：**

      输入的第一行包括一个整数n(1<=n<=500)，代表下面会出现的IP地址的个数。    接下来的n行每行有一个IP地址，IP地址的形式为a.b.c.d，其中a、b、c、d都是整数。


- **输出：**

      可能有多组测试数据，对于每组数据，如果IP地址合法则输出"Yes!”，否则输出"No!”。


- **样例输入：**

  `2255.255.255.255512.12.2.3`


- **样例输出：**

  `Yes!No!`


- **提示：**

  合法的IP地址为：a、b、c、d都是0-255的整数。


- **来源：**

  [*2006年华中科技大学计算机保研机试真题*](http://ac.jobdu.com/problemset.php?search=2006%E5%B9%B4%E5%8D%8E%E4%B8%AD%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E7%9C%9F%E9%A2%98)

- 代码

  ```c
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>

  int main()
  {
      int n, a[5], i, j;
      char s[100];
      while(scanf("%d", &n) != EOF)
      {
      	getchar();
          for(i = 0; i < n; i ++)
          {
              gets(s);
              sscanf(s, "%d.%d.%d.%d", &a[0], &a[1], &a[2], &a[3]);
              for(j = 0; j < 4; j ++) printf("--%d\n", a[j]);
              for(j = 0; j < 4; j ++)
                  if(a[j] < 0 || a[j] > 255)
                  {
                      printf("No!\n");
                      break;
                  }
              if(j == 4) printf("Yes!\n");
          }
      }
      return 0;
  }
  ```

- 注意

  在使用gets之前有个scanf，scanf不读取回车，那么gets认为读到了一行没有字符的字符串，以回车结束，因此需要要用getchar来读取回车！

- 代码二

  ```c
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>

  int main()
  {
      int n, a[5], i, j;
      char s[100];
      while(scanf("%d", &n) != EOF)
      {
          for(i = 0; i < n; i ++)
          {
              scanf("%d.%d.%d.%d", &a[0], &a[1], &a[2], &a[3]);
              for(j = 0; j < 4; j ++)
                  if(a[j] < 0 || a[j] > 255)
                  {
                      printf("No!\n");
                      break;
                  }
              if(j == 4) printf("Yes!\n");
          }
      }
      return 0;
  }
  ```


# ----------【动态规划】----------

![QQ截图20170813232747](C:\Users\bob\Pictures\QQ截图20170813232747.png)

我为人人 就像走路往前看 j > i

人人为我 就像走路往后看 j < i

## OPENJUDGE 4118:开餐馆

总时间限制: 1000ms 内存限制: 65536kB
描述
北大信息学院的同学小明毕业之后打算创业开餐馆.现在共有n 个地点可供选择。小明打算从中选择合适的位置开设一些餐馆。这 n 个地点排列在同一条直线上。我们用一个整数序列m1, m2, ... mn 来表示他们的相对位置。由于地段关系,开餐馆的利润会有所不同。我们用pi 表示在mi 处开餐馆的利润。为了避免自己的餐馆的内部竞争,餐馆之间的距离必须大于k。请你帮助小明选择一个总利润最大的方案。

输入
标准的输入包含若干组测试数据。输入第一行是整数T (1 <= T <= 1000) ，表明有T组测试数据。紧接着有T组连续的测试。每组测试数据有3行,
第1行:地点总数 n (n < 100), 距离限制 k (k > 0 && k < 1000).
第2行:n 个地点的位置m1 , m2, ... mn ( 1000000 > mi > 0 且为整数,升序排列)
第3行:n 个地点的餐馆利润p1 , p2, ... pn ( 1000 > pi > 0 且为整数)
输出
对于每组测试数据可能的最大利润
样例输入
2
3 11
1 2 15
10 2 30
3 16
1 2 15
10 2 30
样例输出
40
30

```c++
#include<stdio.h>
#include<algorithm>

using namespace std;

int T, n, k;
int m[110], p[110], dp[110];

int main()
{
    int i, j, q;
    scanf("%d", &T);
    for(i = 0; i < T; i ++)
    {
        scanf("%d%d", &n, &k);
        for(j = 0; j < n; j ++)
            scanf("%d", &m[j]);
        for(j = 0; j < n; j ++)
        {
            scanf("%d", &p[j]);
            dp[j] = p[j]; //origin
        }
        for(j = 1; j < n; j ++)
        {
            for(q = 0; q < j; q ++)
            {
                if(m[j] - m[q] > k)
                {
                    dp[j] = max(dp[j], dp[q] + p[j]);
                }
            }
        }
        int ans = dp[0];
        for(j = 1; j < n; j ++)
            if(dp[j] > ans) ans = dp[j];
        printf("%d\n", ans);


    }
    return 0;
}

```




## POJ 1458  最长上升子序列

Common Subsequence

| **Time Limit:** 1000MS       |      | **Memory Limit:** 10000K |
| ---------------------------- | ---- | ------------------------ |
| **Total Submissions:** 54125 |      | **Accepted:** 22489      |

Description

A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = < x1, x2, ..., xm > another sequence Z = < z1, z2, ..., zk > is a subsequence of X if there exists a strictly increasing sequence < i1, i2, ..., ik > of indices of X such that for all j = 1,2,...,k, xij = zj. For example, Z = < a, b, f, c > is a subsequence of X = < a, b, c, f, b, c > with index sequence < 1, 2, 4, 6 >. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.

Input

The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.

Output

For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.

Sample Input
  ```
abcfbc         abfcab
programming    contest 
abcd           mnp
  ```

Sample Output

```
4
2
0
```

Source

[Southeastern Europe 2003](http://poj.org/searchproblem?field=source&key=Southeastern+Europe+2003)

- 思路

  状态：maxLen(i, j)  表示s1左边的i个字符形成的子串，和s2左边的j个字符形成的子串，他们的最长公共子序列的长度

  最终要求的：maxLen(len1, len2)

- 递推公式

  ![QQ截图20170808193157](C:\Users\bob\Pictures\QQ截图20170808193157.png)

  maxLen(n, 0) = 0 (n = 0, 1, ... , len1)

  maxLen(0, n) = 0 (n = 0, 1, ... , len2)

  if(s1[i - 1] == s2[j - 1])

  ​	maxLen(i, j) = maxLen(i - 1, j - 1) + 1;

  else

  ​	maxLen(i, j) = max ( maxLen(i - 1, j), maxLen(i, j - 1) );

  - 实现代码

    ```c
    #include<stdio.h>
    #include<string.h>
    #include<algorithm>
    using namespace std;

    char s1[1000];
    char s2[1000];

    int maxLen[1000][1000];

    int main()
    {
    	while(scanf("%s%s", &s1, &s2) != EOF)
    	{
    		int len1 = strlen(s1), len2 = strlen(s2);
    		for(int i = 0; i <= len1; i ++) //初始化条件
    			maxLen[i][0] = 0;
    		for(int i = 0; i <= len2; i ++)
    			maxLen[0][i] = 0;
    		for(int i = 1; i <= len1; i ++)
    			for(int j = 1; j <= len2; j ++)
    			{
    				if(s1[i - 1] == s2[j - 1])
    				{
    					maxLen[i][j] = maxLen[i - 1][j - 1] + 1;
    				}
    				else
    				{
    					maxLen[i][j] = max( maxLen[i][j - 1], maxLen[i - 1][j]);
    				}
    			}
    		printf("%d\n", maxLen[len1][len2]);
    	}
    	return 0;
    }
    ```

## POJ 1661 Help Jimmy

- 题目

  | **Time Limit:** 1000MS       |      | **Memory Limit:** 10000K |
  | ---------------------------- | ---- | ------------------------ |
  | **Total Submissions:** 12098 |      | **Accepted:** 3989       |

  Description

  "Help Jimmy" 是在下图所示的场景上完成的游戏。 
  ![img](http://poj.org/images/1661_1.jpg)
  场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。 
  Jimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。 
  设计一个程序，计算Jimmy到底地面时可能的最早时间。 

  Input

  第一行是测试数据的组数t（0 <= t <= 20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1 <= N <= 1000，-20000 <= X, X1[i], X2[i] <= 20000，0 < H[i] < Y <= 20000（i = 1..N）。所有坐标的单位都是米。 
  Jimmy的大小和平台的厚度均忽略不计。如果Jimmy恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保证问题一定有解。 

  Output

  对输入的每组测试数据，输出一个整数，Jimmy到底地面时可能的最早时间。

  Sample Input

  1
  3 8 17 20
  0 10 8
  0 10 13
  4 14 3


  Sample Output


  23


  Source

  [POJ Monthly--2004.05.15 CEOI 2000](http://poj.org/searchproblem?field=source&key=POJ+Monthly--2004.05.15+CEOI+2000)

- 思路

  划分为子问题：

  minLeft(k) : 从板子的左边下落的最短时间

  minRight(k) : 从板子右边下落的最短时间

  输入之后需要对板子进行排序！

  具体见 动态规划之几个例题.pdf

- AC代码-记忆递归型

  ```c++
  #include<stdio.h>
  #include<algorithm>
  #define INFINITE 1000000 //<limites.h> INT_MAX害苦了我
  using namespace std;

  int t, N, X, Y, MAX;

  struct Plat
  {
  	int left, right, height;
  };

  Plat plat[1010];

  bool cmp(Plat a, Plat b)
  {
      return a.height > b.height;
  }

  int minLeftTime[1010];//开头大写函数 小写数组
  int minRightTime[1010];

  int MinLeftTime(int k);
  int MinRightTime(int k);

  int findLeftBelow(int k)
  {
  	for(int i = k + 1; i <= N; i ++)
  		if(plat[i].left <= plat[k].left && plat[i].right >= plat[k].left)
  			return i; //找得到（一开始写成了返回k）
  	return 0; //找不到
  }

  int findRightBelow(int k)
  {
  	for(int i = k + 1; i <= N; i ++)
  		if(plat[i].left <= plat[k].right && plat[i].right >= plat[k].right)
  			return i; //找得到
  	return 0; //找不到
  }

  int MinLeftTime(int k) 
  {
  	if(minLeftTime[k] != -1) return minLeftTime[k];
  	int leftBelow = findLeftBelow(k);
  	if(!leftBelow) //下边没有板子
  	{
  		if(plat[k].height > MAX)
  			minLeftTime[k] = INFINITE;
  		else
  			minLeftTime[k] = plat[k].height;
  	}
  	else
  	{
  		int t = plat[k].height - plat[leftBelow].height;
  		if(t > MAX) minLeftTime[k] = INFINITE;
  		else minLeftTime[k] = t + min( MinLeftTime(leftBelow) + plat[k].left - plat[leftBelow].left, MinRightTime(leftBelow) + plat[leftBelow].right - plat[k].left);
  	}
  	return minLeftTime[k];
  }

  int MinRightTime(int k)
  {
  	if(minRightTime[k] != -1) return minRightTime[k];
  	int rightBelow = findRightBelow(k);
  	if(!rightBelow)
  	{
  		if(plat[k].height > MAX)
  			minRightTime[k] = INFINITE;
  		else
  			minRightTime[k] = plat[k].height;
  	}
  	else
  	{
  		int t = plat[k].height - plat[rightBelow].height;
  		if(t > MAX) minRightTime[k] = INFINITE;
  		else
  		{
  			int t1 = MinLeftTime(rightBelow) + plat[k].right - plat[rightBelow].left;
  			int t2 = MinRightTime(rightBelow) + plat[rightBelow].right - plat[k].right;
  			minRightTime[k] = t + min(t1 , t2);
  		}
  	}
  	return minRightTime[k];
  }

  int main()
  {
  	//freopen("1661input.txt", "r", stdin);
  	scanf("%d", &t);
  	for(int i = 0; i < t; i ++)
  	{
  		scanf("%d%d%d%d", &N, &X, &Y, &MAX);
  		for(int j = 1; j <= N; j ++)
  		{
  			scanf("%d%d%d", &plat[j].left, &plat[j].right, &plat[j].height);
  		}
  		
  		plat[0].left = X;
  		plat[0].right = X;
  		plat[0].height = Y;
  		
  		sort(plat, plat + N + 1, cmp);

  		for(int i = 0; i <= N; i ++)
  		{
  			minLeftTime[i] = -1;
  			minRightTime[i] = -1;
  		}
  		printf("%d\n", MinLeftTime(0));
  	}
  	return 0;
  }
  ```

- 错误原因

  1. 返回变量没有看清，写错了
  2. INT_MAX 加整数之后和别的数字进行比较
  3. 相似的函数可以和并简化——放在函数参数里面进行简化

- AC代码-人人为我递推型

  ```c++
  #include<stdio.h>
  #include<algorithm>
  #define INFINITE 1000000 //<limites.h> INT_MAX
  using namespace std;

  int t, N, X, Y, MAX;

  struct Plat
  {
  	int left, right, height;
  };

  Plat plat[1010];

  bool cmp(Plat a, Plat b)
  {
      return a.height > b.height;
  }

  int minLeftTime[1010];//开头大写函数 小写数组
  int minRightTime[1010];

  int findLeftBelow(int k)
  {
  	for(int i = k + 1; i <= N; i ++)
  		if(plat[i].left <= plat[k].left && plat[i].right >= plat[k].left)
  			return i; //找得到（一开始写成了返回k）
  	return 0; //找不到
  }

  int findRightBelow(int k)
  {
  	for(int i = k + 1; i <= N; i ++)
  		if(plat[i].left <= plat[k].right && plat[i].right >= plat[k].right)
  			return i; //找得到
  	return 0; //找不到
  }

  void findMinLeftTime(int k)
  {
  	int leftBelow = findLeftBelow(k);
  	if(!leftBelow) //下边没有板子
  	{
  		if(plat[k].height > MAX)
  			minLeftTime[k] = INFINITE;
  		else
  			minLeftTime[k] = plat[k].height;
  	}
  	else
  	{
  		int t = plat[k].height - plat[leftBelow].height;
  		if(t > MAX) minLeftTime[k] = INFINITE;
  		else
  		{
  			int t1 = minLeftTime[leftBelow] + plat[k].left - plat[leftBelow].left;
  			int t2 = minRightTime[leftBelow] + plat[leftBelow].right - plat[k].left;
  			minLeftTime[k] = t + min(t1, t2);
  		}
  	}
  }

  void findMinRightTime(int k)
  {
  	int rightBelow = findRightBelow(k);
  	if(!rightBelow)
  	{
  		if(plat[k].height > MAX)
  			minRightTime[k] = INFINITE;
  		else
  			minRightTime[k] = plat[k].height;
  	}
  	else
  	{
  		int t = plat[k].height - plat[rightBelow].height;
  		if(t > MAX) minRightTime[k] = INFINITE;
  		else
  		{
  			int t1 = minLeftTime[rightBelow] + plat[k].right - plat[rightBelow].left;
  			int t2 = minRightTime[rightBelow] + plat[rightBelow].right - plat[k].right;
  			minRightTime[k] = t + min(t1 , t2);
  		}
  	}
  }

  int main()
  {
  	//freopen("1661input.txt", "r", stdin);
  	scanf("%d", &t);
  	for(int i = 0; i < t; i ++)
  	{
  		scanf("%d%d%d%d", &N, &X, &Y, &MAX);

  		for(int j = 1; j <= N; j ++)
  		{
  			scanf("%d%d%d", &plat[j].left, &plat[j].right, &plat[j].height);
  		}

  		plat[0].left = X;
  		plat[0].right = X;
  		plat[0].height = Y;

  		sort(plat, plat + N + 1, cmp);

  		for(int i = 0; i <= N; i ++)
  		{
  			minLeftTime[i] = -1;
  			minRightTime[i] = -1;
  		}
  		
  		for(int i = N; i >= 0; i --)
  		{
  			findMinLeftTime(i);
  			findMinRightTime(i);
  		}

  		printf("%d\n", min(minLeftTime[0], minRightTime[0]));
  	}
  	return 0;
  }
  ```




## OPEN JUDGE 5:最佳加法表达式

http://cxsjsxmooc.openjudge.cn/2017t2summerw5/5/

- 题目

  - 总时间限制: 

    1000ms

  - 内存限制: 

    65536kB


  - 描述

    给定n个1到9的数字，要求在数字之间摆放m个加号(加号两边必须有数字），使得所得到的加法表达式的值最小，并输出该值。例如，在1234中摆放1个加号，最好的摆法就是12+34,和为36

  - 输入

    有不超过15组数据每组数据两行。第一行是整数m，表示有m个加号要放( 0<=m<=50)第二行是若干个数字。数字总数n不超过50,且 m <= n-1

  - 输出

    对每组数据，输出最小加法表达式的值

  - 样例输入

    `21234561123456412345`

  - 样例输出

    `10257915`

  - 提示

    要用到高精度计算，即用数组来存放long long 都装不下的大整数，并用模拟列竖式的办法进行大整数的加法。

- 思路

  ```c
  L(n, m)表示在n个字母的字符串中插入m个加号 所形成的最小表达式的值
  if(n < m + 1) INF
  else if(m == 0) value(1, n);
  else
    {
      min(  L(k, m - 1) + value(k + 1, n) ) k = 1, ... n - 1;
    }
  ```

- 没有加入高精度的代码

  ```c++
  #include<stdio.h>
  #include<string.h>
  #include<algorithm>
  #define INFINITE 0x3f3f3f3f
  using namespace std;

  int len, plus_num;

  char num[60]; //数字长度不超过50

  long long l[55][55];

  long long value(int start, int end)
  {
  	int t = 1;
  	long long ans = 0;
  	for(int i = end - 1; i >= start - 1; i --)
  	{
  		ans += t * ( num[i] - '0' );
  		t *= 10;
  	}
  	return ans;
  }

  long long L(int len, int plus_num)
  {
  	if(l[len][plus_num] != -1) return l[len][plus_num]; //记忆
  	if(len < plus_num + 1) l[len][plus_num] = INFINITE; //不符合条件的输入
  	else if(plus_num == 0) l[len][plus_num] = value(1, len);
  	else
  	{
  		long long min = INFINITE;
  		for(int k = 1; k <= len - 1; k ++)
  		{
  			long long t = L(k, plus_num - 1) + value(k + 1, len);
  			if(t < min) min = t;
  		}
  		l[len][plus_num] = min;
  	}
  	return l[len][plus_num];
  }

  int main()
  {
  	while(scanf("%d %s", &plus_num, &num) != EOF)
  	{
  		len = strlen(num);
  		memset(l, -1, sizeof(l));
  		printf( "%lld\n", L(len, plus_num) );
  	}
  }
  ```




## OPEN JUDGE 1088 滑雪

描述

Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。

输入

第一行表示有几组测试数据，输入的第二行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表高度h，0<=h<=10000。

输出

输出最长区域的长度。

样例输入


1
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9


样例输出


25

- “我为人人”型的思路

  设longest(i, j)表示从 i,j 出发的最长滑坡长度。

  动态规划必须保证无后效性，因此先对所有高度进行从小到大排序。

  然后依次遍历每一个高度，如果找到后面的有相邻的节点，那么如果后面的节点(p, q)高度大于当前结点，那么更新：

  longest(p, q) = max( longest(p, q), longest(i, j) + 1)

  （第一次没有想到排序消除后效性，第二次没有写max直接更新了。）

- 代码

  ```c
  #include<stdio.h>
  #include<string.h>
  #include<math.h>
  #include<algorithm>
  using namespace std;
  #define MAX 110

  int longest[MAX][MAX], a[MAX][MAX], r, c, h, node_num = 0;

  struct Node
  {
  	int h;
  	int x; //行坐标
  	int y; //列坐标
  };
  Node node[MAX*MAX];

  bool cmp(Node a, Node b)
  {
  	return a.h < b.h;
  }

  void updateLongest() //我为人人
  {
  	sort(node, node + node_num, cmp); //按照高度从低到高进行排序，每次更新比当前结点大的邻接节点的值
  	for(int i = 0; i < node_num - 1; i ++)// 排序保证了无后效性
  	{
  		int x_now = node[i].x, y_now = node[i].y;
  		for(int j = i + 1; j < node_num; j++) //向后寻找高于now的邻接节点
  		{
  			int x_later = node[j].x, y_later = node[j].y;
  			if(node[j].h > node[i].h)
  				if( (pow(x_now - x_later, 2) + pow(y_now - y_later, 2)) == 1)
  					longest[x_later][y_later] = max( longest[x_now][y_now] + 1, longest[x_later][y_later]);
  		}
  	}
  }

  int getLongest()
  {
  	int max = 0;
  	for(int i = 0; i < r; i ++)
  		for(int j = 0; j < c; j ++)
  			if(longest[i][j] > max) max = longest[i][j];
  	return max;
  }

  int main()
  {
  	//freopen("1088in.txt", "r", stdin);
  	scanf("%d%d", &r, &c);
  	for(int i = 0; i < r; i ++)
  		for(int j = 0; j < c; j ++)
  		{
  			scanf("%d", &node[node_num].h);
  			node[node_num].x = i;
  			node[node_num].y = j;
  			node_num ++;
  			longest[i][j] = 1;
  		}
  	updateLongest();
  	printf("%d\n", getLongest());
  	return 0;
  }

  ```

  ​

## 题目1011：最大连续子序列
时间限制：1 秒内存限制：32 兆特殊判题：否提交：7428解决：3533
题目描述：
    给定K个整数的序列{ N1, N2, ..., NK }，其任意连续子序列可表示为{ Ni, Ni+1, ..., Nj }，其中 1 <= i <= j <= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。
输入：
    测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K< 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。
输出：
    对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。
样例输入：
6
-2 11 -4 13 -5 -2
10
-10 1 2 3 4 -5 -23 3 7 -21
6
5 -8 3 2 5 0
1
10
3
-1 -5 -2
3
-1 0 -2
0
样例输出：
20 11 13
10 1 4
10 3 5
10 10 10
0 -1 -2
0 0 0

- 思路
  tmp记录当前的最大和，当tmp<=0的时候，不管之后加上什么数字都会减小或者不变，因此此时应该tmp = 0，重新开始计数。

- 代码
```c++
#include<stdio.h>
#include<limits.h>
#define MAX 10010

int a[MAX];

int main()
{
    int k;
    while(scanf("%d", &k) != EOF && k != 0)
    {
        int max_sum = INT_MIN, first, last, tmp_first, tmp_last, tmp = 0;
        int tmp_sum = 0;

        for(int i = 0; i < k; i ++) scanf("%d", &a[i]);
        first = last = tmp_first = tmp_last = a[0];
        for(int i = 0; i < k; i ++)
        {
            tmp += a[i];
            tmp_last = a[i];
            if(tmp <= 0) //restart
            {
                tmp = 0;
                tmp_first = tmp_last = a[i + 1];
            }
            else
            {
                if(tmp > max_sum)
                {
                    max_sum = tmp;
                    first = tmp_first;
                    last = tmp_last;
                }
            }
        }
        if(max_sum < 0)
        {
            max_sum = 0;
            first = a[0];
            last = a[k - 1];
        }
        printf("%d %d %d\n", max_sum, first, last);
    }
    return 0;
}


```



# ----------【数学】----------

## 找质数，因子只需要遍历到bound = (int)sqrt(x) + 1。

因为如果一个数有大于bound的因子，那么一定有小于bound的因子，之前已经遍历过。

## 题目1207：质因数的个数

**时间限制：**1 秒

**内存限制：**32 兆

**特殊判题：**否

**提交：**10085

**解决：**3278

- **题目描述：**

  求正整数N(N>1)的质因数的个数。相同的质因数需要重复计算。如120=2*2*2*3*5，共有5个质因数。


- **输入：**

  可能有多组测试数据，每组测试数据的输入是一个正整数N，(1<N<10^9)。


- **输出：**

  对于每组数据，输出N的质因数的个数。


- **样例输入：**

  `120`


- **样例输出：**

  `5`


- **提示：**

  注意：1不是N的质因数；若N为质数，N是N的质因数。


- **来源：**

  [*2007年清华大学计算机研究生机试真题*](http://ac.jobdu.com/problemset.php?search=2007%E5%B9%B4%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A0%94%E7%A9%B6%E7%94%9F%E6%9C%BA%E8%AF%95%E7%9C%9F%E9%A2%98)

- 思路1：

  首先通过素数筛法将100000之内的素数找出来，然后让n依次除每个素数，除不尽则换下一个，直到除尽或者超过素数个数。超过素数个数说明还有一个质因子比100000大，因此计数个数加1。输出计数结果。

- 思路2：

  每个数对其2  ~  (int)sqrt(n) + 1 的数字依次进行遍历，除以能出的尽的数字，那么除的数字一定是质数，因为一个数的因子一定比自己小，比如一个数是8的倍数，那么当它除完了所有能除的2之后，必然不能被8整除。

- 难点：时空限制 Runtime Error越界

- 思路1代码：

  ```c
  #include<stdio.h>
  #include<string.h>
  #define MAX 100000

  int prime[MAX + 10];
  int mark[MAX + 10];
  int prime_num = 0;

  void getPrime()
  {
  	memset(mark, 0, sizeof(mark));
  	prime_num = 1;
  	for(int i = 2; i < MAX; i ++)
  	{
  		if(mark[i] == 0)
  		{
  			prime[prime_num ++] = i;
  			int j = i + i;
  			while(j <= MAX)
  			{
  				mark[j] = 1;
  				j += i;
  			}
  		}
      }
  }

  int main()
  {
  	getPrime();
  	int n;
  	while(scanf("%d", &n) != EOF)
  	{
  		int ans = 0, point = 1;
  		while(n != 1)
  		{
  			while(n % prime[point] == 0)
  			{
  				n = n / prime[point];
  				ans ++;
  			}
  			point ++;
  			if(point >= prime_num) //错误原因：prime_num写成了MAX越界
  			{
  				ans ++;
  				break;
  			}
  		}
  		printf("%d\n", ans);
  	}
  	return 0;
  }
  ```

- 思路2代码：

  ```c
  #include<stdio.h>
  #include<math.h>
  #include<string.h>

  int main()
  {
  	int n;
  	while(scanf("%d", &n) != EOF)
  	{
  		int bound = (int)sqrt(n) + 1, ans = 0, i;
  		for(i = 2; i <= bound; i ++)
  		{
  			while(n % i == 0)
  			{
  				ans ++;
  				n /= i;
  			}
  			if(n == 1) break;
  		}
  		if(i > bound && n > 1) ans ++;
  		printf("%d\n", ans);
  	}
  	return 0;
  }
  ```



## 题目1056：最大公约数

**时间限制：**1 秒

**内存限制：**32 兆

**特殊判题：**否

**提交：**9274

**解决：**6180

- **题目描述：**

  输入两个正整数，求其最大公约数。


- **输入：**

  测试数据有多组，每组输入两个正整数。


- **输出：**

  对于每组输入,请输出其最大公约数。


- **样例输入：**

  `49 14`


- **样例输出：**

  `7`

- 递归和非递归代码

  ```c
  #include<stdio.h>

  int gcd1(int a, int b) //digui
  {
  	if(b == 0) return a;
  	else return gcd1(b, a%b);
  }

  int gcd2(int a, int b) //feidigui
  {
  	int t;
  	while(b != 0)
  	{
  		t = a;
  		a = b;
  		b = t%b;
  	}
  	return a;
  }

  int main()
  {
  	int a, b;
  	while(scanf("%d%d", &a, &b) != EOF)
  	{
  		printf("%d\n", gcd1(a, b));
  	}
  	return 0;
  }
  ```




最小公倍数：就是两个数的积除以最大公约数。

## 题目1336：液晶屏裁剪

**时间限制：**1 秒

**内存限制：**32 兆

**特殊判题：**否

**提交：**1182

**解决：**288

- **题目描述：**

  苏州某液晶厂一直生产a * b大小规格的液晶屏幕，由于该厂的加工工艺限制，液晶屏的边长都为整数。最近由于市场需求发生变化，x : y比例的显示器比较流行，该厂为了适应市场需求，需要改造原生产线，并将库存的a * b大小的液晶屏进行裁剪，使之适应市场的需求。该厂同时希望，将a * b大小的液晶屏裁剪之后，不仅符合x : y的比例要求，同时在转换为新比例液晶屏的过程中，保证因切割而丢弃的液晶边角料最少。你的任务就是根据原液晶屏大小和新的屏幕的比例，判断是否能将库存的液晶屏转换为符合要求的液晶屏大小，并求出新的液晶屏的大小a’ b’；若不能加工成新的，则输出0 0。注：新的液晶屏边长和旧的液晶屏边长都为整数，并且长和宽不能交换。


- **输入：**

  测试数据包括多个，每个测试数据一行。每行四个整数 a b x y1） a、b表示原库存液晶屏的长和宽2） x、y表示新的液晶屏的长宽比例x : y其中，1 <= a, b, x, y <= 10^9。


- **输出：**

  对应每个测试案例，输出一行，每行包含两个整数，由空格隔开：1)       若答案存在，则输出新的液晶屏的长宽 a’ b’2)       若不存在，则输出0 0


- **样例输入：**
  1920 1600 16 9
  800 600 4 3
  800 600 3 4
  1 1 1 2



- **样例输出：**

1920 1080
800 600
450 600
0 0

- 思路1：

  先将xy约分，同时除以最大公约数，作为初始值，依次加自身的初始值，直到x>a|y>b为止。最后再减去一个x和y的初始值，输出。注意有可能超时。==结果大于ab的时候可能超过int表示范围，因此需要用long long==。

- 思路2：

  先将xy约分，然后取a/x, b/y的小者，分别乘xy，输出。

- 代码

  ```c
  #include<stdio.h>

  int gcd(int a, int b)
  {
  	if(b == 0) return a;
  	else return gcd(b, a%b);
  }

  int main()
  {
  	int a, b, x, y;
  	while(scanf("%d%d%d%d", &a, &b, &x, &y) != EOF)
  	{
  		int t, flag = 0, ax, bx, m;
  		long long ans1 = 0, ans2 = 0;
  		int z = gcd(x, y);
  		x /= z;
  		y /= z;
  		/*if(a >= x && b >= y)
  		{
  			ax = a/x;
  			bx = b/y;
  			m = ax > bx ? bx : ax;
  			ans1 = x*m;
  			ans2 = y*m;
  		}*/
          if(x <= a && y <= b)
          {
          	while(ans1 <= a && ans2 <= b)
  			{
  				ans1 += x;
  				ans2 += y;
  			}
  			ans1 -= x;
  			ans2 -= y;
          }
  		printf("%d %d\n", ans1, ans2);
  	}
  	return 0;
  }
  ```

  ​



# ----------【其他】----------

## 数据范围

int表示的最大位数是10， long long 是19

## &位运算 &&逻辑运算

&是一个位运算符，就是将两个二进制的数逐位相与，就是都是1才是1，只要有一个为0则为0，结果是相与之后的结果。
&&是一个逻辑运算符，就是判断两个表达式的真假性，只有两个表达式同时为真才为真，有一个为假则为假，具有短路性质。

## 最大值的选取

```c
#include<stdio.h>
#include<algorithm>
using namespace std;

int main()
{
	int a = 5, b = 100;
	printf("%d\n", max(a, b));
	return 0;
}
```

如果问题中各数据的范围明确，那么无穷大的设定不是问题，在不明确的情况下，很多程序员都取0x7fffffff作为无穷大，因为这是32-bit int的最大值。如果这个无穷大只用于一般的比较（比如求最小值时min变量的初值），那么0x7fffffff确实是一个完美的选择，但是在更多的情况下，0x7fffffff并不是一个好的选择。

1. 很多时候我们并不只是单纯拿无穷大来作比较，而是会运算后再做比较，例如在大部分最短路径算法中都会使用的松弛操作：
   if (d[u]+w[u][v]<d[v]) d[v]=d[u]+w[u][v];
   我们知道如果u,v之间没有边，那么w[u][v]=INF，如果我们的INF取0x7fffffff，那么d[u]+w[u][v]会溢出而变成负数，我们的松弛操作便出错了，更一般的说，0x7fffffff不能满足“无穷大加一个有穷的数依然是无穷大”，它变成了一个很小的负数。

2. 除了要满足加上一个常数依然是无穷大之外，我们的常量还应该满足“无穷大加无穷大依然是无穷大”，至少两个无穷大相加不应该出现灾难性的错误，这一点上0x7fffffff依然不能满足我们。

   所以我们需要一个更好的家伙来顶替0x7fffffff，最严谨的办法当然是对无穷大进行特别处理而不是找一个很大很大的常量来代替它（或者说模拟它），但是这样会让我们的编程过程变得很麻烦。在我读过的代码中，最精巧的无穷大常量取值是0x3f3f3f3f，我不知道是谁最先开始使用这个精妙的常量来做无穷大，不过我的确是从[一位不认识的ACMer(ID:Staginner)的博客](http://www.cnblogs.com/staginner/)上学到的，他/她的很多代码中都使用了这个常量，于是我自己也尝试了一下，发现非常好用，而当我对这个常量做更深入的分析时，就发现它真的是非常精巧了。

3. 0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。

4. 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。

5. 最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。

所以在通常的场合下，0x3f3f3f3f真的是一个非常棒的选择。

**一定要注意题目数字的范围，int表示的最大位数是10， long long 是19。**若超过就应该用模拟竖式的方法进行大整数的运算（高精度）。

## [char *a 与char a[\] 的区别](http://www.cnblogs.com/kaituorensheng/archive/2012/10/23/2736069.html)

char *a = "hello" 中的a是指向第一个字符‘a'的一个指针

char a[20] = "hello" 中数组名a也是执行数组第一个字符‘h’的指针

但二者并**不相同**：

看实例：把两个字符串相加：

![img](http://pic002.cnblogs.com/images/2012/408927/2012102318322585.png)

结果：

![img](http://pic002.cnblogs.com/images/2012/408927/2012102318333449.png)

**对比：**

![img](http://pic002.cnblogs.com/images/2012/408927/2012102318341667.png)

结果：

![img](http://pic002.cnblogs.com/images/2012/408927/2012102318344579.png)

把字符串加到指针所指的字串上去，出现段错误，**本质**原因：*d="0123456789"存放在常量区，是无法修的。而数组是存放在栈中，是可以修改的。两者区别如下：

**一. ”读“ ”写“ 能力**

- char *a = "abcd";  此时"abcd"存放在常量区。通过指针只可以访问字符串常量，而不可以改变它。
- 而char a[20] = "abcd"； 此时 "abcd"存放在栈。可以通过指针去访问和修改数组内容。

**二. 赋值时刻**

- char *a = "abcd"; 是在编译时就确定了（因为为常量）。
- 而char a[20] = "abcd"； 在运行时确定

**三. 存取效率**

- char *a = "abcd"; 存于静态存储区。在[栈](http://baike.baidu.com/view/93201.htm)上的数组比指针所指向字符串快。因此慢
- 而char a[20] = "abcd"； 存于栈上。快

**另外注意：**

char a[] = "01234",虽然没有指明字符串的长度，但是此时系统已经开好了，就是大小为6-----'0' '1' '2' '3' '4' '5' '\0'，(**注意strlen(a)是不计‘\0’**)

看一**结构**中出现的同样的问题：

这样红色部分在调用Init函数时会出现“Segment Default", 因为此时 指针n是静态的，只有“读”的本事，不可以改变。

 

## 内存分配方式

内存分配有三种：静态存储区、堆区和栈区。他们的功能不同，对他们使用方式也就不同。

1. **静态存储区**：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。
2. **栈区**：在执行函数时，**函数（包括main函数）**内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（任何变量都处于站区，例如int a[] = {1, 2},变量a处于栈区。数组的内容也存在于栈区。）
3. **堆区**：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，并立即将指针置位NULL，防止产生野指针。